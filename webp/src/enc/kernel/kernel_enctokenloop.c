#include <stdio.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
//#include "../../../src_syn/vp8_hls_syn.h"


#define DEBUG_BLOCK 0
#define DEBUG_PickBestIntra4 0
#define DEBUG_TOKENS 0
#define MULT_8B(a, b) (((a) * (b) + 128) >> 8)
#define MIN_PAGE_SIZE 8192          
#define FIXED_PROBA_BIT (1u << 14)

#define FLATNESS_LIMIT_I16 10      
#define FLATNESS_LIMIT_I4  3       
#define FLATNESS_LIMIT_UV  2       
#define FLATNESS_PENALTY   140     

#define RD_DISTO_MULT      256  

typedef signed   char int8_t;
typedef unsigned char uint8_t;
typedef signed   short int16_t;
typedef unsigned short uint16_t;
typedef signed   int int32_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
typedef long long int int64_t;
int g_last = 0;

int g_x = 0;
int g_y = 0;

typedef int64_t score_t;     

#define BPS 32   
#define WEBP_ALIGN_CST 31

#define YUV_SIZE_ENC (BPS * 16)
#define PRED_SIZE_ENC (32 * BPS + 16 * BPS + 8 * BPS)   
#define Y_OFF_ENC    (0)
#define U_OFF_ENC    (16)
#define V_OFF_ENC    (16 + 8)

#define I16DC16 (0 * 16 * BPS)
#define I16TM16 (I16DC16 + 16)
#define I16VE16 (1 * 16 * BPS)
#define I16HE16 (I16VE16 + 16)
#define C8DC8 (2 * 16 * BPS)
#define C8TM8 (C8DC8 + 1 * 16)
#define C8VE8 (2 * 16 * BPS + 8 * BPS)
#define C8HE8 (C8VE8 + 1 * 16)
#define I4DC4 (3 * 16 * BPS +  0)
#define I4TM4 (I4DC4 +  4)
#define I4VE4 (I4DC4 +  8)
#define I4HE4 (I4DC4 + 12)
#define I4RD4 (I4DC4 + 16)
#define I4VR4 (I4DC4 + 20)
#define I4LD4 (I4DC4 + 24)
#define I4VL4 (I4DC4 + 28)
#define I4HD4 (3 * 16 * BPS + 4 * BPS)
#define I4HU4 (I4HD4 + 4)
#define I4TMP (I4HD4 + 8)

#define MAX_COST ((score_t)0x7fffffffffffffLL)
#define I4_PENALTY 14000  
#define QFIX 17
#define BIAS(b)  ((b) << (QFIX - 8))

#define LARGEST_Y_STRIDE                1920
#define LARGEST_UV_STRIDE               960

#define LARGEST_MB_W                    240
#define LARGEST_MB_H                    135

#define LARGEST_PREDS_W_PRE             (LARGEST_MB_W + 1)
#define LARGEST_PREDS_W                 (4 * LARGEST_MB_W + 1)
#define LARGEST_PREDS_H                 (4 * LARGEST_MB_H + 1)
#define MATRIX_SIZE                     80
#define MIN_COUNT 96  


enum { B_DC_PRED = 0,   
       B_TM_PRED = 1,
       B_VE_PRED = 2,
       B_HE_PRED = 3,
       B_RD_PRED = 4,
       B_VR_PRED = 5,
       B_LD_PRED = 6,
       B_VL_PRED = 7,
       B_HD_PRED = 8,
       B_HU_PRED = 9,
       NUM_BMODES = B_HU_PRED + 1 - B_DC_PRED,  

       DC_PRED = B_DC_PRED, V_PRED = B_VE_PRED,
       H_PRED = B_HE_PRED, TM_PRED = B_TM_PRED,
       B_PRED = NUM_BMODES,   
       NUM_PRED_MODES = 4,

       B_DC_PRED_NOTOP = 4,
       B_DC_PRED_NOLEFT = 5,
       B_DC_PRED_NOTOPLEFT = 6,
       NUM_B_DC_MODES = 7 };

enum { MB_FEATURE_TREE_PROBS = 3,
       NUM_MB_SEGMENTS = 4,
       NUM_REF_LF_DELTAS = 4,
       NUM_MODE_LF_DELTAS = 4,    
       MAX_NUM_PARTITIONS = 8,
       NUM_TYPES = 4,   
       NUM_BANDS = 8,
       NUM_CTX = 3,
       NUM_PROBAS = 11
};

enum { MAX_LF_LEVELS = 64,       
       MAX_VARIABLE_LEVEL = 67,  
       MAX_LEVEL = 2047          
};

#define TYPES_SIZE                        NUM_BANDS * NUM_CTX * NUM_PROBAS
#define BANDS_SIZE                        NUM_CTX * NUM_PROBAS
#define CTX_SIZE                          NUM_PROBAS


typedef struct EncloopInputData {
  int width;
  int height;
  int filter_sharpness;
  int show_compressed;
  int extra_info_type;
  int stats_add;
  int simple;
  int num_parts;
  int max_i4_header_bits; 
  int lf_stats_status;
  int use_skip_proba;
  int method;
  int rd_opt;
}EncloopInputData;

typedef struct EncLoopOutputData {
  int32_t range;
  int32_t value;
  int32_t run;
  int32_t nb_bits;
  int32_t pos;
  int32_t max_pos;
  int32_t error;
  int32_t max_i4_header_bits; 

  int32_t cur_page_;
  int32_t page_count_;
  int32_t left_;                
  int32_t page_size_;           
  int32_t error_;         
}EncLoopOutputData;

typedef struct {
  uint8_t   yuv_in_p[YUV_SIZE_ENC];           
  uint8_t   yuv_out_p[YUV_SIZE_ENC];         
  uint8_t   yuv_out2_p[YUV_SIZE_ENC];       
  uint8_t   yuv_p_p[PRED_SIZE_ENC];        

  uint8_t   mb_info_p[5 * LARGEST_MB_W];  
  uint8_t   preds_p[LARGEST_PREDS_W * LARGEST_PREDS_H + LARGEST_PREDS_W_PRE];     
  uint32_t  nz_p[LARGEST_MB_W + 1 + 1]; 

  uint8_t   y_left_p[32];           
  uint8_t   uv_left_p[32];         

  uint8_t   i4_boundary_p[37];   
  int       top_nz_p[9];        
  int       left_nz_p[9];      

  uint8_t   y_top_p[LARGEST_MB_W * 16];
  uint8_t   uv_top_p[LARGEST_MB_W * 16];
} VP8EncIteratorPointer;

#define PAGE_COUNT            2
#define TOKENS_COUNT_PER_PAGE 155040
#define TOKENS_SIZE           2      
#define PAGE_POINTER_SIZE     8 
#define PAGE_SIZE             ((TOKENS_COUNT_PER_PAGE * TOKENS_SIZE) + PAGE_POINTER_SIZE)
typedef struct {
  uint16_t tokens_[PAGE_COUNT * TOKENS_COUNT_PER_PAGE];
  int cur_page_;
  int page_count_;
  int left_;                
  int page_size_;          
  int error_;         
  int index_using_buf;
} VP8TBufferKernel;

typedef struct {
  uint8_t coeffs_p[NUM_TYPES * NUM_BANDS * NUM_CTX * NUM_PROBAS];
  uint16_t level_cost_p[NUM_TYPES * NUM_BANDS * NUM_CTX * (MAX_VARIABLE_LEVEL + 1)];
  uint32_t stats_p[NUM_TYPES * NUM_BANDS * NUM_CTX * NUM_PROBAS];
  uint16_t* remapped_costs_p[NUM_TYPES * 16 * NUM_CTX]; 
  uint8_t bw_buf_p[408000];
  uint64_t bit_count_p[4 * 3];
  uint64_t sse_p[4];
  uint64_t sse_count[1];
  int block_count_p[3];
  int dirty_[1];
} VP8EncLoopPointer;

typedef struct {
  int           x_, y_;                      
  int           mb_w, mb_h;
  int           preds_w, preds_h;
  int           uv_width, uv_height;
  int           y_stride_, uv_stride_;      
  int           i4_;                       
  int           do_trellis_;              
  uint64_t      luma_bits_;              
  uint64_t      uv_bits_;               
  int           max_i4_header_bits; 
} VP8EncIteratorVariable;


typedef enum LevelsIndex{
  Y_DC_LEVELS = 0,
  Y_AC_LEVELS,
  Y_UV_LEVELS,
} LevelsIndex;

typedef struct {
  score_t D, SD;              
  score_t H, R, score;        
  int16_t y_dc_levels[16];    
  int16_t y_ac_levels[16][16];
  int16_t uv_levels[4 + 4][16];
  int mode_i16;               
  uint8_t modes_i4[16];       
  int mode_uv;                
  uint32_t nz;                
} VP8ModeScore;

typedef struct VP8Matrix {
  uint32_t q_[16];        
  uint32_t iq_[16];       
  uint32_t bias_[16];     
  uint32_t zthresh_[16];  
  uint32_t sharpen_[16];  
} VP8Matrix;

typedef struct VP8Residual VP8Residual;
struct VP8Residual {
  int first;
  int last;
  int coeff_type;

  int16_t coeffs[16];

};

typedef struct EncloopSegmentData {
  int quant[NUM_MB_SEGMENTS];
  int fstrength[NUM_MB_SEGMENTS];
  int max_edge[NUM_MB_SEGMENTS];
  int min_disto[NUM_MB_SEGMENTS];
  int lambda_i16[NUM_MB_SEGMENTS];
  int lambda_i4[NUM_MB_SEGMENTS];
  int lambda_uv[NUM_MB_SEGMENTS];
  int lambda_mode[NUM_MB_SEGMENTS];
  int tlambda[NUM_MB_SEGMENTS];
  int lambda_trellis_i16[NUM_MB_SEGMENTS];
  int lambda_trellis_i4[NUM_MB_SEGMENTS];
  int lambda_trellis_uv[NUM_MB_SEGMENTS];
}EncloopSegmentData;

const int VP8I16ModeOffsets[4] = { I16DC16, I16TM16, I16VE16, I16HE16 };
const int VP8UVModeOffsets[4] = { C8DC8, C8TM8, C8VE8, C8HE8 };

static const uint8_t clip1[255 + 511 + 1] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
  0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
  0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
  0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
  0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44,
  0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
  0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c,
  0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
  0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74,
  0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
  0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
  0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
  0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
  0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
  0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc,
  0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8,
  0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4,
  0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0,
  0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec,
  0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
  0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const int VP8Scan[16] = {  
  0 +  0 * BPS,  4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS,
  0 +  4 * BPS,  4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS,
  0 +  8 * BPS,  4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS,
  0 + 12 * BPS,  4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS,
};

static const int VP8ScanUV[4 + 4] = {
  0 + 0 * BPS,   4 + 0 * BPS, 0 + 4 * BPS,  4 + 4 * BPS,    
  8 + 0 * BPS,  12 + 0 * BPS, 8 + 4 * BPS, 12 + 4 * BPS     
};

static const uint8_t kZigzag[16] = {
  0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15
};

const uint8_t VP8EncBands[16 + 1] = {
  0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7,
  0  
};

static const uint8_t kNorm[128] = {  
  7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0
};

static const uint8_t kNewRange[128] = {
  127, 127, 191, 127, 159, 191, 223, 127, 143, 159, 175, 191, 207, 223, 239,
  127, 135, 143, 151, 159, 167, 175, 183, 191, 199, 207, 215, 223, 231, 239,
  247, 127, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 179,
  183, 187, 191, 195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239,
  243, 247, 251, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149,
  151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179,
  181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209,
  211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239,
  241, 243, 245, 247, 249, 251, 253, 127
};

const uint8_t VP8Cat3[] = { 173, 148, 140 };
const uint8_t VP8Cat4[] = { 176, 155, 140, 135 };
const uint8_t VP8Cat5[] = { 180, 157, 141, 134, 130 };
const uint8_t VP8Cat6[] =
  { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129 };


const int VP8I4ModeOffsets[NUM_BMODES] = {
  I4DC4, I4TM4, I4VE4, I4HE4, I4RD4, I4VR4, I4LD4, I4VL4, I4HD4, I4HU4
};

static const uint8_t VP8TopLeftI4[16] = {
  17, 21, 25, 29,
  13, 17, 21, 25,
  9,  13, 17, 21,
  5,   9, 13, 17
};


const uint16_t VP8FixedCostsUV[4] = { 302, 984, 439, 642 };
const uint16_t VP8FixedCostsI16[4] = { 663, 919, 872, 919 };
const uint16_t VP8FixedCostsI4[NUM_BMODES][NUM_BMODES][NUM_BMODES] = {
  { {   40, 1151, 1723, 1874, 2103, 2019, 1628, 1777, 2226, 2137 },
    {  192,  469, 1296, 1308, 1849, 1794, 1781, 1703, 1713, 1522 },
    {  142,  910,  762, 1684, 1849, 1576, 1460, 1305, 1801, 1657 },
    {  559,  641, 1370,  421, 1182, 1569, 1612, 1725,  863, 1007 },
    {  299, 1059, 1256, 1108,  636, 1068, 1581, 1883,  869, 1142 },
    {  277, 1111,  707, 1362, 1089,  672, 1603, 1541, 1545, 1291 },
    {  214,  781, 1609, 1303, 1632, 2229,  726, 1560, 1713,  918 },
    {  152, 1037, 1046, 1759, 1983, 2174, 1358,  742, 1740, 1390 },
    {  512, 1046, 1420,  753,  752, 1297, 1486, 1613,  460, 1207 },
    {  424,  827, 1362,  719, 1462, 1202, 1199, 1476, 1199,  538 } },
  { {  240,  402, 1134, 1491, 1659, 1505, 1517, 1555, 1979, 2099 },
    {  467,  242,  960, 1232, 1714, 1620, 1834, 1570, 1676, 1391 },
    {  500,  455,  463, 1507, 1699, 1282, 1564,  982, 2114, 2114 },
    {  672,  643, 1372,  331, 1589, 1667, 1453, 1938,  996,  876 },
    {  458,  783, 1037,  911,  738,  968, 1165, 1518,  859, 1033 },
    {  504,  815,  504, 1139, 1219,  719, 1506, 1085, 1268, 1268 },
    {  333,  630, 1445, 1239, 1883, 3672,  799, 1548, 1865,  598 },
    {  399,  644,  746, 1342, 1856, 1350, 1493,  613, 1855, 1015 },
    {  622,  749, 1205,  608, 1066, 1408, 1290, 1406,  546,  971 },
    {  500,  753, 1041,  668, 1230, 1617, 1297, 1425, 1383,  523 } },
  { {  394,  553,  523, 1502, 1536,  981, 1608, 1142, 1666, 2181 },
    {  655,  430,  375, 1411, 1861, 1220, 1677, 1135, 1978, 1553 },
    {  690,  640,  245, 1954, 2070, 1194, 1528,  982, 1972, 2232 },
    {  559,  834,  741,  867, 1131,  980, 1225,  852, 1092,  784 },
    {  690,  875,  516,  959,  673,  894, 1056, 1190, 1528, 1126 },
    {  740,  951,  384, 1277, 1177,  492, 1579, 1155, 1846, 1513 },
    {  323,  775, 1062, 1776, 3062, 1274,  813, 1188, 1372,  655 },
    {  488,  971,  484, 1767, 1515, 1775, 1115,  503, 1539, 1461 },
    {  740, 1006,  998,  709,  851, 1230, 1337,  788,  741,  721 },
    {  522, 1073,  573, 1045, 1346,  887, 1046, 1146, 1203,  697 } },
  { {  105,  864, 1442, 1009, 1934, 1840, 1519, 1920, 1673, 1579 },
    {  534,  305, 1193,  683, 1388, 2164, 1802, 1894, 1264, 1170 },
    {  305,  518,  877, 1108, 1426, 3215, 1425, 1064, 1320, 1242 },
    {  683,  732, 1927,  257, 1493, 2048, 1858, 1552, 1055,  947 },
    {  394,  814, 1024,  660,  959, 1556, 1282, 1289,  893, 1047 },
    {  528,  615,  996,  940, 1201,  635, 1094, 2515,  803, 1358 },
    {  347,  614, 1609, 1187, 3133, 1345, 1007, 1339, 1017,  667 },
    {  218,  740,  878, 1605, 3650, 3650, 1345,  758, 1357, 1617 },
    {  672,  750, 1541,  558, 1257, 1599, 1870, 2135,  402, 1087 },
    {  592,  684, 1161,  430, 1092, 1497, 1475, 1489, 1095,  822 } },
  { {  228, 1056, 1059, 1368,  752,  982, 1512, 1518,  987, 1782 },
    {  494,  514,  818,  942,  965,  892, 1610, 1356, 1048, 1363 },
    {  512,  648,  591, 1042,  761,  991, 1196, 1454, 1309, 1463 },
    {  683,  749, 1043,  676,  841, 1396, 1133, 1138,  654,  939 },
    {  622, 1101, 1126,  994,  361, 1077, 1203, 1318,  877, 1219 },
    {  631, 1068,  857, 1650,  651,  477, 1650, 1419,  828, 1170 },
    {  555,  727, 1068, 1335, 3127, 1339,  820, 1331, 1077,  429 },
    {  504,  879,  624, 1398,  889,  889, 1392,  808,  891, 1406 },
    {  683, 1602, 1289,  977,  578,  983, 1280, 1708,  406, 1122 },
    {  399,  865, 1433, 1070, 1072,  764,  968, 1477, 1223,  678 } },
  { {  333,  760,  935, 1638, 1010,  529, 1646, 1410, 1472, 2219 },
    {  512,  494,  750, 1160, 1215,  610, 1870, 1868, 1628, 1169 },
    {  572,  646,  492, 1934, 1208,  603, 1580, 1099, 1398, 1995 },
    {  786,  789,  942,  581, 1018,  951, 1599, 1207,  731,  768 },
    {  690, 1015,  672, 1078,  582,  504, 1693, 1438, 1108, 2897 },
    {  768, 1267,  571, 2005, 1243,  244, 2881, 1380, 1786, 1453 },
    {  452,  899, 1293,  903, 1311, 3100,  465, 1311, 1319,  813 },
    {  394,  927,  942, 1103, 1358, 1104,  946,  593, 1363, 1109 },
    {  559, 1005, 1007, 1016,  658, 1173, 1021, 1164,  623, 1028 },
    {  564,  796,  632, 1005, 1014,  863, 2316, 1268,  938,  764 } },
  { {  266,  606, 1098, 1228, 1497, 1243,  948, 1030, 1734, 1461 },
    {  366,  585,  901, 1060, 1407, 1247,  876, 1134, 1620, 1054 },
    {  452,  565,  542, 1729, 1479, 1479, 1016,  886, 2938, 1150 },
    {  555, 1088, 1533,  950, 1354,  895,  834, 1019, 1021,  496 },
    {  704,  815, 1193,  971,  973,  640, 1217, 2214,  832,  578 },
    {  672, 1245,  579,  871,  875,  774,  872, 1273, 1027,  949 },
    {  296, 1134, 2050, 1784, 1636, 3425,  442, 1550, 2076,  722 },
    {  342,  982, 1259, 1846, 1848, 1848,  622,  568, 1847, 1052 },
    {  555, 1064, 1304,  828,  746, 1343, 1075, 1329, 1078,  494 },
    {  288, 1167, 1285, 1174, 1639, 1639,  833, 2254, 1304,  509 } },
  { {  342,  719,  767, 1866, 1757, 1270, 1246,  550, 1746, 2151 },
    {  483,  653,  694, 1509, 1459, 1410, 1218,  507, 1914, 1266 },
    {  488,  757,  447, 2979, 1813, 1268, 1654,  539, 1849, 2109 },
    {  522, 1097, 1085,  851, 1365, 1111,  851,  901,  961,  605 },
    {  709,  716,  841,  728,  736,  945,  941,  862, 2845, 1057 },
    {  512, 1323,  500, 1336, 1083,  681, 1342,  717, 1604, 1350 },
    {  452, 1155, 1372, 1900, 1501, 3290,  311,  944, 1919,  922 },
    {  403, 1520,  977, 2132, 1733, 3522, 1076,  276, 3335, 1547 },
    {  559, 1374, 1101,  615,  673, 2462,  974,  795,  984,  984 },
    {  547, 1122, 1062,  812, 1410,  951, 1140,  622, 1268,  651 } },
  { {  165,  982, 1235,  938, 1334, 1366, 1659, 1578,  964, 1612 },
    {  592,  422,  925,  847, 1139, 1112, 1387, 2036,  861, 1041 },
    {  403,  837,  732,  770,  941, 1658, 1250,  809, 1407, 1407 },
    {  896,  874, 1071,  381, 1568, 1722, 1437, 2192,  480, 1035 },
    {  640, 1098, 1012, 1032,  684, 1382, 1581, 2106,  416,  865 },
    {  559, 1005,  819,  914,  710,  770, 1418,  920,  838, 1435 },
    {  415, 1258, 1245,  870, 1278, 3067,  770, 1021, 1287,  522 },
    {  406,  990,  601, 1009, 1265, 1265, 1267,  759, 1017, 1277 },
    {  968, 1182, 1329,  788, 1032, 1292, 1705, 1714,  203, 1403 },
    {  732,  877, 1279,  471,  901, 1161, 1545, 1294,  755,  755 } },
  { {  111,  931, 1378, 1185, 1933, 1648, 1148, 1714, 1873, 1307 },
    {  406,  414, 1030, 1023, 1910, 1404, 1313, 1647, 1509,  793 },
    {  342,  640,  575, 1088, 1241, 1349, 1161, 1350, 1756, 1502 },
    {  559,  766, 1185,  357, 1682, 1428, 1329, 1897, 1219,  802 },
    {  473,  909, 1164,  771,  719, 2508, 1427, 1432,  722,  782 },
    {  342,  892,  785, 1145, 1150,  794, 1296, 1550,  973, 1057 },
    {  208, 1036, 1326, 1343, 1606, 3395,  815, 1455, 1618,  712 },
    {  228,  928,  890, 1046, 3499, 1711,  994,  829, 1720, 1318 },
    {  768,  724, 1058,  636,  991, 1075, 1319, 1324,  616,  825 },
    {  305, 1167, 1358,  899, 1587, 1587,  987, 1988, 1332,  501 } }
};


static const uint16_t kWeightY[16] = {
  38, 32, 20, 9, 32, 28, 17, 7, 20, 17, 10, 4, 9, 7, 4, 2
};

const uint16_t VP8LevelFixedCosts[MAX_LEVEL + 1] = {
  0,  256,  256,  256,  256,  432,  618,  630,
  731,  640,  640,  828,  901,  948, 1021, 1101,
  1174, 1221, 1294, 1042, 1085, 1115, 1158, 1202,
  1245, 1275, 1318, 1337, 1380, 1410, 1453, 1497,
  1540, 1570, 1613, 1280, 1295, 1317, 1332, 1358,
  1373, 1395, 1410, 1454, 1469, 1491, 1506, 1532,
  1547, 1569, 1584, 1601, 1616, 1638, 1653, 1679,
  1694, 1716, 1731, 1775, 1790, 1812, 1827, 1853,
  1868, 1890, 1905, 1727, 1733, 1742, 1748, 1759,
  1765, 1774, 1780, 1800, 1806, 1815, 1821, 1832,
  1838, 1847, 1853, 1878, 1884, 1893, 1899, 1910,
  1916, 1925, 1931, 1951, 1957, 1966, 1972, 1983,
  1989, 1998, 2004, 2027, 2033, 2042, 2048, 2059,
  2065, 2074, 2080, 2100, 2106, 2115, 2121, 2132,
  2138, 2147, 2153, 2178, 2184, 2193, 2199, 2210,
  2216, 2225, 2231, 2251, 2257, 2266, 2272, 2283,
  2289, 2298, 2304, 2168, 2174, 2183, 2189, 2200,
  2206, 2215, 2221, 2241, 2247, 2256, 2262, 2273,
  2279, 2288, 2294, 2319, 2325, 2334, 2340, 2351,
  2357, 2366, 2372, 2392, 2398, 2407, 2413, 2424,
  2430, 2439, 2445, 2468, 2474, 2483, 2489, 2500,
  2506, 2515, 2521, 2541, 2547, 2556, 2562, 2573,
  2579, 2588, 2594, 2619, 2625, 2634, 2640, 2651,
  2657, 2666, 2672, 2692, 2698, 2707, 2713, 2724,
  2730, 2739, 2745, 2540, 2546, 2555, 2561, 2572,
  2578, 2587, 2593, 2613, 2619, 2628, 2634, 2645,
  2651, 2660, 2666, 2691, 2697, 2706, 2712, 2723,
  2729, 2738, 2744, 2764, 2770, 2779, 2785, 2796,
  2802, 2811, 2817, 2840, 2846, 2855, 2861, 2872,
  2878, 2887, 2893, 2913, 2919, 2928, 2934, 2945,
  2951, 2960, 2966, 2991, 2997, 3006, 3012, 3023,
  3029, 3038, 3044, 3064, 3070, 3079, 3085, 3096,
  3102, 3111, 3117, 2981, 2987, 2996, 3002, 3013,
  3019, 3028, 3034, 3054, 3060, 3069, 3075, 3086,
  3092, 3101, 3107, 3132, 3138, 3147, 3153, 3164,
  3170, 3179, 3185, 3205, 3211, 3220, 3226, 3237,
  3243, 3252, 3258, 3281, 3287, 3296, 3302, 3313,
  3319, 3328, 3334, 3354, 3360, 3369, 3375, 3386,
  3392, 3401, 3407, 3432, 3438, 3447, 3453, 3464,
  3470, 3479, 3485, 3505, 3511, 3520, 3526, 3537,
  3543, 3552, 3558, 2816, 2822, 2831, 2837, 2848,
  2854, 2863, 2869, 2889, 2895, 2904, 2910, 2921,
  2927, 2936, 2942, 2967, 2973, 2982, 2988, 2999,
  3005, 3014, 3020, 3040, 3046, 3055, 3061, 3072,
  3078, 3087, 3093, 3116, 3122, 3131, 3137, 3148,
  3154, 3163, 3169, 3189, 3195, 3204, 3210, 3221,
  3227, 3236, 3242, 3267, 3273, 3282, 3288, 3299,
  3305, 3314, 3320, 3340, 3346, 3355, 3361, 3372,
  3378, 3387, 3393, 3257, 3263, 3272, 3278, 3289,
  3295, 3304, 3310, 3330, 3336, 3345, 3351, 3362,
  3368, 3377, 3383, 3408, 3414, 3423, 3429, 3440,
  3446, 3455, 3461, 3481, 3487, 3496, 3502, 3513,
  3519, 3528, 3534, 3557, 3563, 3572, 3578, 3589,
  3595, 3604, 3610, 3630, 3636, 3645, 3651, 3662,
  3668, 3677, 3683, 3708, 3714, 3723, 3729, 3740,
  3746, 3755, 3761, 3781, 3787, 3796, 3802, 3813,
  3819, 3828, 3834, 3629, 3635, 3644, 3650, 3661,
  3667, 3676, 3682, 3702, 3708, 3717, 3723, 3734,
  3740, 3749, 3755, 3780, 3786, 3795, 3801, 3812,
  3818, 3827, 3833, 3853, 3859, 3868, 3874, 3885,
  3891, 3900, 3906, 3929, 3935, 3944, 3950, 3961,
  3967, 3976, 3982, 4002, 4008, 4017, 4023, 4034,
  4040, 4049, 4055, 4080, 4086, 4095, 4101, 4112,
  4118, 4127, 4133, 4153, 4159, 4168, 4174, 4185,
  4191, 4200, 4206, 4070, 4076, 4085, 4091, 4102,
  4108, 4117, 4123, 4143, 4149, 4158, 4164, 4175,
  4181, 4190, 4196, 4221, 4227, 4236, 4242, 4253,
  4259, 4268, 4274, 4294, 4300, 4309, 4315, 4326,
  4332, 4341, 4347, 4370, 4376, 4385, 4391, 4402,
  4408, 4417, 4423, 4443, 4449, 4458, 4464, 4475,
  4481, 4490, 4496, 4521, 4527, 4536, 4542, 4553,
  4559, 4568, 4574, 4594, 4600, 4609, 4615, 4626,
  4632, 4641, 4647, 3515, 3521, 3530, 3536, 3547,
  3553, 3562, 3568, 3588, 3594, 3603, 3609, 3620,
  3626, 3635, 3641, 3666, 3672, 3681, 3687, 3698,
  3704, 3713, 3719, 3739, 3745, 3754, 3760, 3771,
  3777, 3786, 3792, 3815, 3821, 3830, 3836, 3847,
  3853, 3862, 3868, 3888, 3894, 3903, 3909, 3920,
  3926, 3935, 3941, 3966, 3972, 3981, 3987, 3998,
  4004, 4013, 4019, 4039, 4045, 4054, 4060, 4071,
  4077, 4086, 4092, 3956, 3962, 3971, 3977, 3988,
  3994, 4003, 4009, 4029, 4035, 4044, 4050, 4061,
  4067, 4076, 4082, 4107, 4113, 4122, 4128, 4139,
  4145, 4154, 4160, 4180, 4186, 4195, 4201, 4212,
  4218, 4227, 4233, 4256, 4262, 4271, 4277, 4288,
  4294, 4303, 4309, 4329, 4335, 4344, 4350, 4361,
  4367, 4376, 4382, 4407, 4413, 4422, 4428, 4439,
  4445, 4454, 4460, 4480, 4486, 4495, 4501, 4512,
  4518, 4527, 4533, 4328, 4334, 4343, 4349, 4360,
  4366, 4375, 4381, 4401, 4407, 4416, 4422, 4433,
  4439, 4448, 4454, 4479, 4485, 4494, 4500, 4511,
  4517, 4526, 4532, 4552, 4558, 4567, 4573, 4584,
  4590, 4599, 4605, 4628, 4634, 4643, 4649, 4660,
  4666, 4675, 4681, 4701, 4707, 4716, 4722, 4733,
  4739, 4748, 4754, 4779, 4785, 4794, 4800, 4811,
  4817, 4826, 4832, 4852, 4858, 4867, 4873, 4884,
  4890, 4899, 4905, 4769, 4775, 4784, 4790, 4801,
  4807, 4816, 4822, 4842, 4848, 4857, 4863, 4874,
  4880, 4889, 4895, 4920, 4926, 4935, 4941, 4952,
  4958, 4967, 4973, 4993, 4999, 5008, 5014, 5025,
  5031, 5040, 5046, 5069, 5075, 5084, 5090, 5101,
  5107, 5116, 5122, 5142, 5148, 5157, 5163, 5174,
  5180, 5189, 5195, 5220, 5226, 5235, 5241, 5252,
  5258, 5267, 5273, 5293, 5299, 5308, 5314, 5325,
  5331, 5340, 5346, 4604, 4610, 4619, 4625, 4636,
  4642, 4651, 4657, 4677, 4683, 4692, 4698, 4709,
  4715, 4724, 4730, 4755, 4761, 4770, 4776, 4787,
  4793, 4802, 4808, 4828, 4834, 4843, 4849, 4860,
  4866, 4875, 4881, 4904, 4910, 4919, 4925, 4936,
  4942, 4951, 4957, 4977, 4983, 4992, 4998, 5009,
  5015, 5024, 5030, 5055, 5061, 5070, 5076, 5087,
  5093, 5102, 5108, 5128, 5134, 5143, 5149, 5160,
  5166, 5175, 5181, 5045, 5051, 5060, 5066, 5077,
  5083, 5092, 5098, 5118, 5124, 5133, 5139, 5150,
  5156, 5165, 5171, 5196, 5202, 5211, 5217, 5228,
  5234, 5243, 5249, 5269, 5275, 5284, 5290, 5301,
  5307, 5316, 5322, 5345, 5351, 5360, 5366, 5377,
  5383, 5392, 5398, 5418, 5424, 5433, 5439, 5450,
  5456, 5465, 5471, 5496, 5502, 5511, 5517, 5528,
  5534, 5543, 5549, 5569, 5575, 5584, 5590, 5601,
  5607, 5616, 5622, 5417, 5423, 5432, 5438, 5449,
  5455, 5464, 5470, 5490, 5496, 5505, 5511, 5522,
  5528, 5537, 5543, 5568, 5574, 5583, 5589, 5600,
  5606, 5615, 5621, 5641, 5647, 5656, 5662, 5673,
  5679, 5688, 5694, 5717, 5723, 5732, 5738, 5749,
  5755, 5764, 5770, 5790, 5796, 5805, 5811, 5822,
  5828, 5837, 5843, 5868, 5874, 5883, 5889, 5900,
  5906, 5915, 5921, 5941, 5947, 5956, 5962, 5973,
  5979, 5988, 5994, 5858, 5864, 5873, 5879, 5890,
  5896, 5905, 5911, 5931, 5937, 5946, 5952, 5963,
  5969, 5978, 5984, 6009, 6015, 6024, 6030, 6041,
  6047, 6056, 6062, 6082, 6088, 6097, 6103, 6114,
  6120, 6129, 6135, 6158, 6164, 6173, 6179, 6190,
  6196, 6205, 6211, 6231, 6237, 6246, 6252, 6263,
  6269, 6278, 6284, 6309, 6315, 6324, 6330, 6341,
  6347, 6356, 6362, 6382, 6388, 6397, 6403, 6414,
  6420, 6429, 6435, 3515, 3521, 3530, 3536, 3547,
  3553, 3562, 3568, 3588, 3594, 3603, 3609, 3620,
  3626, 3635, 3641, 3666, 3672, 3681, 3687, 3698,
  3704, 3713, 3719, 3739, 3745, 3754, 3760, 3771,
  3777, 3786, 3792, 3815, 3821, 3830, 3836, 3847,
  3853, 3862, 3868, 3888, 3894, 3903, 3909, 3920,
  3926, 3935, 3941, 3966, 3972, 3981, 3987, 3998,
  4004, 4013, 4019, 4039, 4045, 4054, 4060, 4071,
  4077, 4086, 4092, 3956, 3962, 3971, 3977, 3988,
  3994, 4003, 4009, 4029, 4035, 4044, 4050, 4061,
  4067, 4076, 4082, 4107, 4113, 4122, 4128, 4139,
  4145, 4154, 4160, 4180, 4186, 4195, 4201, 4212,
  4218, 4227, 4233, 4256, 4262, 4271, 4277, 4288,
  4294, 4303, 4309, 4329, 4335, 4344, 4350, 4361,
  4367, 4376, 4382, 4407, 4413, 4422, 4428, 4439,
  4445, 4454, 4460, 4480, 4486, 4495, 4501, 4512,
  4518, 4527, 4533, 4328, 4334, 4343, 4349, 4360,
  4366, 4375, 4381, 4401, 4407, 4416, 4422, 4433,
  4439, 4448, 4454, 4479, 4485, 4494, 4500, 4511,
  4517, 4526, 4532, 4552, 4558, 4567, 4573, 4584,
  4590, 4599, 4605, 4628, 4634, 4643, 4649, 4660,
  4666, 4675, 4681, 4701, 4707, 4716, 4722, 4733,
  4739, 4748, 4754, 4779, 4785, 4794, 4800, 4811,
  4817, 4826, 4832, 4852, 4858, 4867, 4873, 4884,
  4890, 4899, 4905, 4769, 4775, 4784, 4790, 4801,
  4807, 4816, 4822, 4842, 4848, 4857, 4863, 4874,
  4880, 4889, 4895, 4920, 4926, 4935, 4941, 4952,
  4958, 4967, 4973, 4993, 4999, 5008, 5014, 5025,
  5031, 5040, 5046, 5069, 5075, 5084, 5090, 5101,
  5107, 5116, 5122, 5142, 5148, 5157, 5163, 5174,
  5180, 5189, 5195, 5220, 5226, 5235, 5241, 5252,
  5258, 5267, 5273, 5293, 5299, 5308, 5314, 5325,
  5331, 5340, 5346, 4604, 4610, 4619, 4625, 4636,
  4642, 4651, 4657, 4677, 4683, 4692, 4698, 4709,
  4715, 4724, 4730, 4755, 4761, 4770, 4776, 4787,
  4793, 4802, 4808, 4828, 4834, 4843, 4849, 4860,
  4866, 4875, 4881, 4904, 4910, 4919, 4925, 4936,
  4942, 4951, 4957, 4977, 4983, 4992, 4998, 5009,
  5015, 5024, 5030, 5055, 5061, 5070, 5076, 5087,
  5093, 5102, 5108, 5128, 5134, 5143, 5149, 5160,
  5166, 5175, 5181, 5045, 5051, 5060, 5066, 5077,
  5083, 5092, 5098, 5118, 5124, 5133, 5139, 5150,
  5156, 5165, 5171, 5196, 5202, 5211, 5217, 5228,
  5234, 5243, 5249, 5269, 5275, 5284, 5290, 5301,
  5307, 5316, 5322, 5345, 5351, 5360, 5366, 5377,
  5383, 5392, 5398, 5418, 5424, 5433, 5439, 5450,
  5456, 5465, 5471, 5496, 5502, 5511, 5517, 5528,
  5534, 5543, 5549, 5569, 5575, 5584, 5590, 5601,
  5607, 5616, 5622, 5417, 5423, 5432, 5438, 5449,
  5455, 5464, 5470, 5490, 5496, 5505, 5511, 5522,
  5528, 5537, 5543, 5568, 5574, 5583, 5589, 5600,
  5606, 5615, 5621, 5641, 5647, 5656, 5662, 5673,
  5679, 5688, 5694, 5717, 5723, 5732, 5738, 5749,
  5755, 5764, 5770, 5790, 5796, 5805, 5811, 5822,
  5828, 5837, 5843, 5868, 5874, 5883, 5889, 5900,
  5906, 5915, 5921, 5941, 5947, 5956, 5962, 5973,
  5979, 5988, 5994, 5858, 5864, 5873, 5879, 5890,
  5896, 5905, 5911, 5931, 5937, 5946, 5952, 5963,
  5969, 5978, 5984, 6009, 6015, 6024, 6030, 6041,
  6047, 6056, 6062, 6082, 6088, 6097, 6103, 6114,
  6120, 6129, 6135, 6158, 6164, 6173, 6179, 6190,
  6196, 6205, 6211, 6231, 6237, 6246, 6252, 6263,
  6269, 6278, 6284, 6309, 6315, 6324, 6330, 6341,
  6347, 6356, 6362, 6382, 6388, 6397, 6403, 6414,
  6420, 6429, 6435, 5303, 5309, 5318, 5324, 5335,
  5341, 5350, 5356, 5376, 5382, 5391, 5397, 5408,
  5414, 5423, 5429, 5454, 5460, 5469, 5475, 5486,
  5492, 5501, 5507, 5527, 5533, 5542, 5548, 5559,
  5565, 5574, 5580, 5603, 5609, 5618, 5624, 5635,
  5641, 5650, 5656, 5676, 5682, 5691, 5697, 5708,
  5714, 5723, 5729, 5754, 5760, 5769, 5775, 5786,
  5792, 5801, 5807, 5827, 5833, 5842, 5848, 5859,
  5865, 5874, 5880, 5744, 5750, 5759, 5765, 5776,
  5782, 5791, 5797, 5817, 5823, 5832, 5838, 5849,
  5855, 5864, 5870, 5895, 5901, 5910, 5916, 5927,
  5933, 5942, 5948, 5968, 5974, 5983, 5989, 6000,
  6006, 6015, 6021, 6044, 6050, 6059, 6065, 6076,
  6082, 6091, 6097, 6117, 6123, 6132, 6138, 6149,
  6155, 6164, 6170, 6195, 6201, 6210, 6216, 6227,
  6233, 6242, 6248, 6268, 6274, 6283, 6289, 6300,
  6306, 6315, 6321, 6116, 6122, 6131, 6137, 6148,
  6154, 6163, 6169, 6189, 6195, 6204, 6210, 6221,
  6227, 6236, 6242, 6267, 6273, 6282, 6288, 6299,
  6305, 6314, 6320, 6340, 6346, 6355, 6361, 6372,
  6378, 6387, 6393, 6416, 6422, 6431, 6437, 6448,
  6454, 6463, 6469, 6489, 6495, 6504, 6510, 6521,
  6527, 6536, 6542, 6567, 6573, 6582, 6588, 6599,
  6605, 6614, 6620, 6640, 6646, 6655, 6661, 6672,
  6678, 6687, 6693, 6557, 6563, 6572, 6578, 6589,
  6595, 6604, 6610, 6630, 6636, 6645, 6651, 6662,
  6668, 6677, 6683, 6708, 6714, 6723, 6729, 6740,
  6746, 6755, 6761, 6781, 6787, 6796, 6802, 6813,
  6819, 6828, 6834, 6857, 6863, 6872, 6878, 6889,
  6895, 6904, 6910, 6930, 6936, 6945, 6951, 6962,
  6968, 6977, 6983, 7008, 7014, 7023, 7029, 7040,
  7046, 7055, 7061, 7081, 7087, 7096, 7102, 7113,
  7119, 7128, 7134, 6392, 6398, 6407, 6413, 6424,
  6430, 6439, 6445, 6465, 6471, 6480, 6486, 6497,
  6503, 6512, 6518, 6543, 6549, 6558, 6564, 6575,
  6581, 6590, 6596, 6616, 6622, 6631, 6637, 6648,
  6654, 6663, 6669, 6692, 6698, 6707, 6713, 6724,
  6730, 6739, 6745, 6765, 6771, 6780, 6786, 6797,
  6803, 6812, 6818, 6843, 6849, 6858, 6864, 6875,
  6881, 6890, 6896, 6916, 6922, 6931, 6937, 6948,
  6954, 6963, 6969, 6833, 6839, 6848, 6854, 6865,
  6871, 6880, 6886, 6906, 6912, 6921, 6927, 6938,
  6944, 6953, 6959, 6984, 6990, 6999, 7005, 7016,
  7022, 7031, 7037, 7057, 7063, 7072, 7078, 7089,
  7095, 7104, 7110, 7133, 7139, 7148, 7154, 7165,
  7171, 7180, 7186, 7206, 7212, 7221, 7227, 7238,
  7244, 7253, 7259, 7284, 7290, 7299, 7305, 7316,
  7322, 7331, 7337, 7357, 7363, 7372, 7378, 7389,
  7395, 7404, 7410, 7205, 7211, 7220, 7226, 7237,
  7243, 7252, 7258, 7278, 7284, 7293, 7299, 7310,
  7316, 7325, 7331, 7356, 7362, 7371, 7377, 7388,
  7394, 7403, 7409, 7429, 7435, 7444, 7450, 7461,
  7467, 7476, 7482, 7505, 7511, 7520, 7526, 7537,
  7543, 7552, 7558, 7578, 7584, 7593, 7599, 7610,
  7616, 7625, 7631, 7656, 7662, 7671, 7677, 7688,
  7694, 7703, 7709, 7729, 7735, 7744, 7750, 7761
};

const uint8_t
VP8CoeffsProba0[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS] = {
  { { { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 }
    },
    { { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128 },
      { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128 },
      { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128 }
    },
    { { 1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128 },
      { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128 },
      { 78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128 },
    },
    { { 1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128 },
      { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128 },
      { 77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128 },
    },
    { { 1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128 },
      { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128 },
      { 37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128 }
    },
    { { 1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128 },
      { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128 },
      { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128 }
    },
    { { 1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128 },
      { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128 },
      { 80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128 }
    },
    { { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 }
    }
  },
  { { { 198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62 },
      { 131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1 },
      { 68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128 }
    },
    { { 1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128 },
      { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128 },
      { 81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128 }
    },
    { { 1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128 },
      { 99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128 },
      { 23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128 }
    },
    { { 1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128 },
      { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128 },
      { 44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128 }
    },
    { { 1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128 },
      { 94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128 },
      { 22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128 }
    },
    { { 1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128 },
      { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128 },
      { 35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128 }
    },
    { { 1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128 },
      { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128 },
      { 45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128 }
    },
    { { 1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128 },
      { 203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
      { 137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128 }
    }
  },
  { { { 253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128 },
      { 175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128 },
      { 73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128 }
    },
    { { 1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128 },
      { 239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128 },
      { 155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128 }
    },
    { { 1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128 },
      { 201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128 },
      { 69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128 }
    },
    { { 1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128 },
      { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128 },
      { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128 }
    },
    { { 1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128 },
      { 190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128 },
      { 149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 }
    },
    { { 1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128 }
    },
    { { 1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128 },
      { 213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128 },
      { 55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128 }
    },
    { { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128 }
    }
  },
  { { { 202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255 },
      { 126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128 },
      { 61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128 }
    },
    { { 1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128 },
      { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128 },
      { 39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128 }
    },
    { { 1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128 },
      { 124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128 },
      { 24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128 }
    },
    { { 1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128 },
      { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128 },
      { 28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128 }
    },
    { { 1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128 },
      { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128 },
      { 20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128 }
    },
    { { 1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128 },
      { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128 },
      { 47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128 }
    },
    { { 1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128 },
      { 141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128 },
      { 42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128 }
    },
    { { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 },
      { 238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128 }
    }
  }
};

const uint8_t
VP8CoeffsUpdateProba[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS] = {
  { { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255 },
      { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    }
  },
  { { { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255 },
      { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255 }
    },
    { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    }
  },
  { { { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255 },
      { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255 }
    },
    { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    }
  },
  { { { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255 },
      { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    },
    { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 },
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
    }
  }
};

const uint16_t VP8EntropyCost[256] = {
  1792, 1792, 1792, 1536, 1536, 1408, 1366, 1280, 1280, 1216,
  1178, 1152, 1110, 1076, 1061, 1024, 1024,  992,  968,  951,
  939,  911,  896,  878,  871,  854,  838,  820,  811,  794,
  786,  768,  768,  752,  740,  732,  720,  709,  704,  690,
  683,  672,  666,  655,  647,  640,  631,  622,  615,  607,
  598,  592,  586,  576,  572,  564,  559,  555,  547,  541,
  534,  528,  522,  512,  512,  504,  500,  494,  488,  483,
  477,  473,  467,  461,  458,  452,  448,  443,  438,  434,
  427,  424,  419,  415,  410,  406,  403,  399,  394,  390,
  384,  384,  377,  374,  370,  366,  362,  359,  355,  351,
  347,  342,  342,  336,  333,  330,  326,  323,  320,  316,
  312,  308,  305,  302,  299,  296,  293,  288,  287,  283,
  280,  277,  274,  272,  268,  266,  262,  256,  256,  256,
  251,  248,  245,  242,  240,  237,  234,  232,  228,  226,
  223,  221,  218,  216,  214,  211,  208,  205,  203,  201,
  198,  196,  192,  191,  188,  187,  183,  181,  179,  176,
  175,  171,  171,  168,  165,  163,  160,  159,  156,  154,
  152,  150,  148,  146,  144,  142,  139,  138,  135,  133,
  131,  128,  128,  125,  123,  121,  119,  117,  115,  113,
  111,  110,  107,  105,  103,  102,  100,   98,   96,   94,
  92,   91,   89,   86,   86,   83,   82,   80,   77,   76,
  74,   73,   71,   69,   67,   66,   64,   63,   61,   59,
  57,   55,   54,   52,   51,   49,   47,   46,   44,   43,
  41,   40,   38,   36,   35,   33,   32,   30,   29,   27,
  25,   24,   22,   21,   19,   18,   16,   15,   13,   12,
  10,    9,    7,    6,    4,    3
};

const uint16_t VP8LevelCodes[MAX_VARIABLE_LEVEL][2] = {
  {0x001, 0x000}, {0x007, 0x001}, {0x00f, 0x005},
  {0x00f, 0x00d}, {0x033, 0x003}, {0x033, 0x003}, {0x033, 0x023},
  {0x033, 0x023}, {0x033, 0x023}, {0x033, 0x023}, {0x0d3, 0x013},
  {0x0d3, 0x013}, {0x0d3, 0x013}, {0x0d3, 0x013}, {0x0d3, 0x013},
  {0x0d3, 0x013}, {0x0d3, 0x013}, {0x0d3, 0x013}, {0x0d3, 0x093},
  {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093},
  {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093},
  {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093},
  {0x0d3, 0x093}, {0x0d3, 0x093}, {0x0d3, 0x093}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053},
  {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x053}, {0x153, 0x153}
};

typedef uint32_t proba_t;   
typedef uint8_t ProbaArray[NUM_CTX][NUM_PROBAS];
typedef proba_t StatsArray[NUM_CTX][NUM_PROBAS];
typedef uint16_t CostArray[NUM_CTX][MAX_VARIABLE_LEVEL + 1];
typedef const uint16_t* CostArrayMap[16][NUM_CTX];

int VP8BitCost(int bit, uint8_t proba) {
  return !bit ? VP8EntropyCost[proba] : VP8EntropyCost[255 - proba];
}

int BranchCost(int nb, int total, int proba) {
  return nb * VP8BitCost(1, proba) + (total - nb) * VP8BitCost(0, proba);
}

int CalcTokenProba(int nb, int total) {
  assert(nb <= total);
  return nb ? (255 - nb * 255 / total) : 255;
}

int FinalizeTokenProbas(VP8EncLoopPointer* proba) {
  int has_changed = 0;
  int size = 0;
  int t, b, c, p;
  for (t = 0; t < NUM_TYPES; ++t) {
    for (b = 0; b < NUM_BANDS; ++b) {
      for (c = 0; c < NUM_CTX; ++c) {
        for (p = 0; p < NUM_PROBAS; ++p) {
          const proba_t stats = proba->stats_p[t*NUM_BANDS*NUM_CTX*NUM_PROBAS + b*NUM_CTX*NUM_PROBAS + c*NUM_PROBAS + p];
          const int nb = (stats >> 0) & 0xffff;
          const int total = (stats >> 16) & 0xffff;
          const int update_proba = VP8CoeffsUpdateProba[t][b][c][p];
          const int old_p = VP8CoeffsProba0[t][b][c][p];
          const int new_p = CalcTokenProba(nb, total);
          const int old_cost = BranchCost(nb, total, old_p)
			+ VP8BitCost(0, update_proba);
          const int new_cost = BranchCost(nb, total, new_p)
			+ VP8BitCost(1, update_proba)
			+ 8 * 256;
          const int use_new_p = (old_cost > new_cost);
          size += VP8BitCost(use_new_p, update_proba);
          if (use_new_p) {  
            proba->coeffs_p[t*NUM_BANDS*NUM_CTX*NUM_PROBAS + b*NUM_CTX*NUM_PROBAS + c*NUM_PROBAS + p] = new_p;
            has_changed |= (new_p != old_p);
            size += 8 * 256;
          } else {
            proba->coeffs_p[t*NUM_BANDS*NUM_CTX*NUM_PROBAS + b*NUM_CTX*NUM_PROBAS + c*NUM_PROBAS + p] = old_p;
          }
        }
      }
    }
  }

  proba->dirty_[0] = has_changed;
  return size;
}

static int VariableLevelCost(int level, const uint8_t probas[NUM_PROBAS]) {
  int pattern = VP8LevelCodes[level - 1][0];
  int bits = VP8LevelCodes[level - 1][1];
  int cost = 0;
  int i;
  for (i = 2; pattern; ++i) {
    if (pattern & 1) {
      cost += VP8BitCost(bits & 1, probas[i]);
    }
    bits >>= 1;
    pattern >>= 1;
  }
  return cost;
}

void VP8CalculateLevelCosts(VP8EncLoopPointer* proba) {
  int ctype, band, ctx;
  if (!proba->dirty_[0]) return;  

  for (ctype = 0; ctype < NUM_TYPES; ++ctype) {
    int n;
    for (band = 0; band < NUM_BANDS; ++band) {
      for (ctx = 0; ctx < NUM_CTX; ++ctx) {
        const uint8_t* const p = proba->coeffs_p + ctype*NUM_BANDS*NUM_CTX*NUM_PROBAS + band*NUM_CTX*NUM_PROBAS + ctx*NUM_PROBAS;
        uint16_t* const table = proba->level_cost_p +
		  ctype*NUM_BANDS*NUM_CTX*(MAX_VARIABLE_LEVEL+1) +
		  band*NUM_CTX*(MAX_VARIABLE_LEVEL+1) +
		  ctx*(MAX_VARIABLE_LEVEL+1);
        const int cost0 = (ctx > 0) ? VP8BitCost(1, p[0]) : 0;
        const int cost_base = VP8BitCost(1, p[1]) + cost0;
        int v;
        table[0] = VP8BitCost(0, p[1]) + cost0;
        for (v = 1; v <= MAX_VARIABLE_LEVEL; ++v) {
          table[v] = cost_base + VariableLevelCost(v, p);
        }
      }
    }
    for (n = 0; n < 16; ++n) {    
      for (ctx = 0; ctx < NUM_CTX; ++ctx) {
        proba->remapped_costs_p[ctype*16*NUM_CTX + n*NUM_CTX + ctx] =
		  proba->level_cost_p +
		  ctype*NUM_BANDS*NUM_CTX*(MAX_VARIABLE_LEVEL+1) +
		  VP8EncBands[n]*NUM_CTX*(MAX_VARIABLE_LEVEL+1) +
		  ctx*(MAX_VARIABLE_LEVEL+1);
      }
    }
  }
  proba->dirty_[0] = 0;
}

int QUANTDIV(uint32_t n, uint32_t iQ, uint32_t B) {
  return (int)((n * iQ + B) >> QFIX);
}

void InitLeft(VP8EncIteratorPointer* const it,
              VP8EncIteratorVariable* const it_var) {
  int i;
  int x = it_var->x_;
  uint8_t* y_left = it->y_left_p + 1;
  uint8_t* u_left = it->uv_left_p + 1;
  uint8_t* v_left = it->uv_left_p + 1 + 16;
  y_left[-1] = u_left[-1] = v_left[-1] =
	(it_var->y_ > 0) ? 129 : 127;
  for (i = 0; i < 16; i++) {
    y_left[i] = 129;
  }
  for (i = 0; i < 8; i++) {
    u_left[i] = 129;
  }
  for (i = 0; i < 8; i++) {
    v_left[i] = 129;
  }
  it->left_nz_p[8] = 0;
}

void ImportBlock(const uint8_t* src, int src_stride,
                 uint8_t* dst, int w, int h) {
  int i, j;
  for (i = 0; i < h; ++i) {
    for (j = 0; j < w; j++) {
      dst[j + i * BPS] = src[j + i * src_stride];
    }
  }
}

void VP8IteratorImport(VP8EncIteratorPointer* const it,
                       VP8EncIteratorVariable* const it_var,
                       uint8_t* y_l, uint8_t* u_l, uint8_t* v_l) {
  
  const int x = it_var->x_;
  const int stride_y = it_var->y_stride_;
  const int stride_uv = it_var->uv_stride_;

  const uint8_t* const ysrc = y_l + x * 16;
  const uint8_t* const usrc = u_l + x * 8;
  const uint8_t* const vsrc = v_l + x * 8;

  ImportBlock(ysrc, stride_y,  it->yuv_in_p + Y_OFF_ENC, 16, 16);
  ImportBlock(usrc, stride_uv, it->yuv_in_p + U_OFF_ENC, 8, 8);
  ImportBlock(vsrc, stride_uv, it->yuv_in_p + V_OFF_ENC, 8, 8);
}

void InitScore(VP8ModeScore* const rd) {
  rd->D  = 0;
  rd->SD = 0;
  rd->R  = 0;
  rd->H  = 0;
  rd->nz = 0;
  rd->score = MAX_COST;
}

void Fill(uint8_t* dst, int value, int size) {
  int j, k;
  for (j = 0; j < size; ++j) {
    for (k = 0; k < size; k++) {
      dst[j * BPS + k] = value;
    }
  }
}

void VerticalPred(uint8_t* dst,
                  const uint8_t* top, int size,
                  int top_status) {
  int j, k;
  if (top_status != 0) {
    for (j = 0; j < size; ++j) {
      for (k = 0; k < size; k++) {
        dst[j * BPS + k] = top[k];
      }
    }
  } else {
    Fill(dst, 127, size);
  }
}

void HorizontalPred(uint8_t* dst,
                    const uint8_t* left, int size,
                    int left_status) {
  if (left_status != 0) {
    int j, k;
    for (j = 0; j < size; ++j) {
      for (k = 0; k < size; k++) {
        dst[j * BPS + k] = left[j];
      }
    }
  } else {
    Fill(dst, 129, size);
  }
}

void TrueMotion(uint8_t* dst, const uint8_t* left,
                const uint8_t* top, int size,
                int left_status, int top_status) {
  int y;
  if (left_status != 0) {
    if (top_status != 0) {
      const uint8_t* const clip = clip1 + 255 - left[-1];
      for (y = 0; y < size; ++y) {
        const uint8_t* const clip_table = clip + left[y];
        int x;
        for (x = 0; x < size; ++x) {
          dst[x + y * BPS] = clip_table[top[x]];
        }
      }
    } else {
      HorizontalPred(dst, left, size, left_status);
    }
  } else {
    if (top_status != 0) {
      VerticalPred(dst, top, size, top_status);
    } else {
      Fill(dst, 129, size);
    }
  }
}

void DCMode(uint8_t* dst,
            const uint8_t* left,
            const uint8_t* top,
            int size, int round, int shift,
            int left_status, int top_status) {
  int DC = 0;
  int j;
  if (top_status != 0) {
    for (j = 0; j < size; ++j) DC += top[j];
    if (left_status != 0) {   
      for (j = 0; j < size; ++j) DC += left[j];
    } else {      
      DC += DC;
    }
    DC = (DC + round) >> shift;
  } else if (left_status != 0) {   
    for (j = 0; j < size; ++j) DC += left[j];
    DC += DC;
    DC = (DC + round) >> shift;
  } else {   
    DC = 0x80;
  }
  Fill(dst, DC, size);
}

void Intra16Preds(uint8_t* dst,
                  const uint8_t* left,
                  const uint8_t* top,
                  int left_status, int top_status) {
  DCMode(I16DC16 + dst, left, top, 16, 16, 5, left_status, top_status);
  VerticalPred(I16VE16 + dst, top, 16, top_status);
  HorizontalPred(I16HE16 + dst, left, 16, left_status);
  TrueMotion(I16TM16 + dst, left, top, 16, left_status, top_status);
}

void IntraChromaPreds(uint8_t* dst, uint8_t* left, uint8_t* top,
                      int left_status, int top_status) {
  uint8_t* top_v;
  uint8_t* dst_v;
  uint8_t* left_v;
  DCMode(C8DC8 + dst, left, top, 8, 8, 4, left_status, top_status);
  VerticalPred(C8VE8 + dst, top, 8, top_status);
  HorizontalPred(C8HE8 + dst, left, 8, left_status);
  TrueMotion(C8TM8 + dst, left, top, 8, left_status, top_status);
  dst_v = dst + 8;
  if (top_status != 0) top_v = top + 8;
  if (left_status != 0) left_v = left + 16;
  DCMode(C8DC8 + dst_v, left_v, top_v, 8, 8, 4, left_status, top_status);
  VerticalPred(C8VE8 + dst_v, top_v, 8, top_status);
  HorizontalPred(C8HE8 + dst_v, left_v, 8, left_status);
  TrueMotion(C8TM8 + dst_v, left_v, top_v, 8, left_status, top_status);
}

void VP8MakeLuma16Preds(VP8EncIteratorVariable* const it_var,
                        VP8EncIteratorPointer* const it) {
  uint8_t* left = it->y_left_p + 1;
  uint8_t* top = it->y_top_p + it_var->x_ * 16;
  if (it_var->x_ == 0 && it_var->y_ == 0) {
    Intra16Preds(it->yuv_p_p, left, top, 0, 0);
  }
  else if (it_var->x_ == 0 && it_var->y_ != 0) {
    Intra16Preds(it->yuv_p_p, left, top, 0, 1);
  }
  else if (it_var->x_ != 0 && it_var->y_ == 0) {
    Intra16Preds(it->yuv_p_p, left, top, 1, 0);
  }
  else {
    Intra16Preds(it->yuv_p_p, left, top, 1, 1);
  }
}

void VP8MakeChroma8Preds(VP8EncIteratorVariable* const it_var,
                         VP8EncIteratorPointer* const it) {
  uint8_t* u_left = it->uv_left_p + 1;
  uint8_t* top = it->uv_top_p + it_var->x_ * 16;
  if (it_var->x_ == 0 && it_var->y_ == 0) {
    IntraChromaPreds(it->yuv_p_p, u_left, top, 0, 0);
  }
  else if (it_var->x_ == 0 && it_var->y_ != 0) {
    IntraChromaPreds(it->yuv_p_p, u_left, top, 0, 1);
  }
  else if (it_var->x_ != 0 && it_var->y_ == 0) {
    IntraChromaPreds(it->yuv_p_p, u_left, top, 1, 0);
  }
  else {
    IntraChromaPreds(it->yuv_p_p, u_left, top, 1, 1);
  }
}

void VP8SetIntra16Mode(VP8EncIteratorVariable* const it_var,
                       VP8EncIteratorPointer* const it, int mode) {
  int x = it_var->x_;
  uint8_t* preds_tmp = it->preds_p + it_var->preds_w + 1 + it_var->y_ * 4 * it_var->preds_w +  4 * it_var->x_;
  int y, z;
  for (y = 0; y < 4; ++y) {
    for (z = 0; z < 4; z++) {
      preds_tmp[z] = mode;
    }
    preds_tmp += it_var->preds_w;
  }
  it->mb_info_p[5 * x + 0] = 1;
}

void VP8SetSkip(VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it, int skip) {
  int x = it_var->x_;
  it->mb_info_p[5 * x + 2] = skip;
}

int GetSSE(const uint8_t* a, const uint8_t* b,
           int w, int h) {
  int count = 0;
  int y, x;
  for (y = 0; y < h; ++y) {
    for (x = 0; x < w; ++x) {
      const int diff = (int)a[x + y * BPS] - b[x + y * BPS];
      count += diff * diff;
    }
  }
  return count;
}

int SSE16x16(const uint8_t* a, const uint8_t* b) {
  return GetSSE(a, b, 16, 16);
}

int SSE16x8(const uint8_t* a, const uint8_t* b) {
  return GetSSE(a, b, 16, 8);
}

int SSE8x8(const uint8_t* a, const uint8_t* b) {
  return GetSSE(a, b, 8, 8);
}

int SSE4x4(const uint8_t* a, const uint8_t* b) {
  return GetSSE(a, b, 4, 4);
}

uint8_t clip_8b(int v) {
  return (!(v & ~0xff)) ? v : (v < 0) ? 0 : 255;
}

#define STORE(x, y, v)												\
  dst[(x) + (y) * BPS] = clip_8b(ref[(x) + (y) * BPS] + ((v) >> 3))

static const int kC1 = 20091 + (1 << 16);
static const int kC2 = 35468;
#define MUL(a, b) (((a) * (b)) >> 16)

void ITransformOne(const uint8_t* ref, const int16_t* in,
                   uint8_t* dst) {
  int C[4 * 4], *tmp;
  int i;
  tmp = C;
  for (i = 0; i < 4; ++i) {    
    const int a = in[0] + in[8];
    const int b = in[0] - in[8];
    const int c = MUL(in[4], kC2) - MUL(in[12], kC1);
    const int d = MUL(in[4], kC1) + MUL(in[12], kC2);
    tmp[0] = a + d;
    tmp[1] = b + c;
    tmp[2] = b - c;
    tmp[3] = a - d;
    tmp += 4;
    in++;
  }

  tmp = C;
  for (i = 0; i < 4; ++i) {    
    const int dc = tmp[0] + 4;
    const int a =  dc +  tmp[8];
    const int b =  dc -  tmp[8];
    const int c = MUL(tmp[4], kC2) - MUL(tmp[12], kC1);
    const int d = MUL(tmp[4], kC1) + MUL(tmp[12], kC2);
    STORE(0, i, a + d);
    STORE(1, i, b + c);
    STORE(2, i, b - c);
    STORE(3, i, a - d);
    tmp++;
  }
}

void FTransform(const uint8_t* src, const uint8_t* ref, int16_t* out) {
  int i;
  int tmp[16];
  for (i = 0; i < 4; ++i, src += BPS, ref += BPS) {
    const int d0 = src[0] - ref[0];   
    const int d1 = src[1] - ref[1];
    const int d2 = src[2] - ref[2];
    const int d3 = src[3] - ref[3];
    const int a0 = (d0 + d3);        
    const int a1 = (d1 + d2);
    const int a2 = (d1 - d2);
    const int a3 = (d0 - d3);
    tmp[0 + i * 4] = (a0 + a1) * 8;   
    tmp[1 + i * 4] = (a2 * 2217 + a3 * 5352 + 1812) >> 9;      
    tmp[2 + i * 4] = (a0 - a1) * 8;
    tmp[3 + i * 4] = (a3 * 2217 - a2 * 5352 +  937) >> 9;
  }
  for (i = 0; i < 4; ++i) {
    const int a0 = (tmp[0 + i] + tmp[12 + i]);  
    const int a1 = (tmp[4 + i] + tmp[ 8 + i]);
    const int a2 = (tmp[4 + i] - tmp[ 8 + i]);
    const int a3 = (tmp[0 + i] - tmp[12 + i]);
    out[0 + i] = (a0 + a1 + 7) >> 4;            
    out[4 + i] = ((a2 * 2217 + a3 * 5352 + 12000) >> 16) + (a3 != 0);
    out[8 + i] = (a0 - a1 + 7) >> 4;
    out[12+ i] = ((a3 * 2217 - a2 * 5352 + 51000) >> 16);
  }
}

void FTransform2(const uint8_t* src, const uint8_t* ref, int16_t* out) {
  FTransform(src, ref, out);
  FTransform(src + 4, ref + 4, out + 16);
}

void FTransformWHT(const int16_t* in, int16_t* out) {
  int32_t tmp[16];
  int i;
  for (i = 0; i < 4; ++i, in += 64) {
    const int a0 = (in[0 * 16] + in[2 * 16]);  
    const int a1 = (in[1 * 16] + in[3 * 16]);
    const int a2 = (in[1 * 16] - in[3 * 16]);
    const int a3 = (in[0 * 16] - in[2 * 16]);
    tmp[0 + i * 4] = a0 + a1;   
    tmp[1 + i * 4] = a3 + a2;
    tmp[2 + i * 4] = a3 - a2;
    tmp[3 + i * 4] = a0 - a1;
  }
  for (i = 0; i < 4; ++i) {
    const int a0 = (tmp[0 + i] + tmp[8 + i]);  
    const int a1 = (tmp[4 + i] + tmp[12+ i]);
    const int a2 = (tmp[4 + i] - tmp[12+ i]);
    const int a3 = (tmp[0 + i] - tmp[8 + i]);
    const int b0 = a0 + a1;    
    const int b1 = a3 + a2;
    const int b2 = a3 - a2;
    const int b3 = a0 - a1;
    out[ 0 + i] = b0 >> 1;     
    out[ 4 + i] = b1 >> 1;
    out[ 8 + i] = b2 >> 1;
    out[12 + i] = b3 >> 1;
  }
}

void TransformWHT(const int16_t* in, int16_t* out) {
  int tmp[16];
  int i;
  for (i = 0; i < 4; ++i) {
    const int a0 = in[0 + i] + in[12 + i];
    const int a1 = in[4 + i] + in[ 8 + i];
    const int a2 = in[4 + i] - in[ 8 + i];
    const int a3 = in[0 + i] - in[12 + i];
    tmp[0  + i] = a0 + a1;
    tmp[8  + i] = a0 - a1;
    tmp[4  + i] = a3 + a2;
    tmp[12 + i] = a3 - a2;
  }
  for (i = 0; i < 4; ++i) {
    const int dc = tmp[0 + i * 4] + 3;    
    const int a0 = dc             + tmp[3 + i * 4];
    const int a1 = tmp[1 + i * 4] + tmp[2 + i * 4];
    const int a2 = tmp[1 + i * 4] - tmp[2 + i * 4];
    const int a3 = dc             - tmp[3 + i * 4];
    out[ 0] = (a0 + a1) >> 3;
    out[16] = (a3 + a2) >> 3;
    out[32] = (a0 - a1) >> 3;
    out[48] = (a3 - a2) >> 3;
    out += 64;
  }
}

void ITransform(const uint8_t* ref, const int16_t* in,
				uint8_t* dst, int do_two) {
  ITransformOne(ref, in, dst);
  if (do_two) {
    ITransformOne(ref + 4, in + 16, dst + 4);
  }
}

int QuantizeBlockWHT(int16_t in[16], VP8ModeScore* const rd,
                     const VP8Matrix* const mtx
                     ) {
  int16_t *out = rd->y_dc_levels;
  int n, last = -1;
  for (n = 0; n < 16; ++n) {
    const int j = kZigzag[n];
    const int sign = (in[j] < 0);
    const uint32_t coeff = sign ? -in[j] : in[j];
    if (coeff > mtx->zthresh_[j]) {
      const uint32_t Q = mtx->q_[j];
      const uint32_t iQ = mtx->iq_[j];
      const uint32_t B = mtx->bias_[j];
      int level = QUANTDIV(coeff, iQ, B);
      if (level > MAX_LEVEL) level = MAX_LEVEL;
      if (sign) level = -level;
      in[j] = level * Q;
      out[n] = level;
      if (level) last = n;
    } else {
      out[n] = 0;
      in[j] = 0;
    }
  }
  return (last >= 0);
}

int QuantizeBlock(int16_t in[16], int16_t out[16],
                  const VP8Matrix* const mtx) {
  int last = -1;
  int n;
  for (n = 0; n < 16; ++n) {
    const int j = kZigzag[n];
    const int sign = (in[j] < 0);
    const uint32_t coeff = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
    if (coeff > mtx->zthresh_[j]) {
      const uint32_t Q = mtx->q_[j];
      const uint32_t iQ = mtx->iq_[j];
      const uint32_t B = mtx->bias_[j];
      int level = QUANTDIV(coeff, iQ, B);
      if (level > MAX_LEVEL) level = MAX_LEVEL;
      if (sign) level = -level;
      in[j] = level * Q;
      out[n] = level;
      if (level) last = n;
    } else {
      out[n] = 0;
      in[j] = 0;
    }
  }
  return (last >= 0);
}

int QuantizeBlockYAcLevel(int16_t in[16], VP8ModeScore* const rd,
						  const VP8Matrix* const mtx, int index, int offset) {
  int16_t *out = rd->y_ac_levels[index] + offset;
  int last = -1;
  int n;
  for (n = 0; n < 16; ++n) {
    const int j = kZigzag[n];
    const int sign = (in[j] < 0);
    const uint32_t coeff = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
    if (coeff > mtx->zthresh_[j]) {
      const uint32_t Q = mtx->q_[j];
      const uint32_t iQ = mtx->iq_[j];
      const uint32_t B = mtx->bias_[j];
      int level = QUANTDIV(coeff, iQ, B);
      if (level > MAX_LEVEL) level = MAX_LEVEL;
      if (sign) level = -level;
      in[j] = level * Q;
      out[n] = level;
      if (level) last = n;
    } else {
      out[n] = 0;
      in[j] = 0;
    }
  }
  return (last >= 0);
}

int QuantizeBlockUvLevels(int16_t in[16], VP8ModeScore* const rd,
						  const VP8Matrix* const mtx, int index, int offset) {
  int16_t *out = rd->uv_levels[index] + offset;
  int last = -1;
  int n;
  for (n = 0; n < 16; ++n) {
    const int j = kZigzag[n];
    const int sign = (in[j] < 0);
    const uint32_t coeff = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
    if (coeff > mtx->zthresh_[j]) {
      const uint32_t Q = mtx->q_[j];
      const uint32_t iQ = mtx->iq_[j];
      const uint32_t B = mtx->bias_[j];
      int level = QUANTDIV(coeff, iQ, B);
      if (level > MAX_LEVEL) level = MAX_LEVEL;
      if (sign) level = -level;
      in[j] = level * Q;
      out[n] = level;
      if (level) last = n;
    } else {
      out[n] = 0;
      in[j] = 0;
    }
  }
  return (last >= 0);
}

int Quantize2Blocks(int16_t in[], int16_t out[],
                    const VP8Matrix* const mtx) {
  int nz;
  nz  = QuantizeBlock(in + 0 * 16, out + 0 * 16, mtx) << 0;
  nz |= QuantizeBlock(in + 1 * 16, out + 1 * 16, mtx) << 1;
  return nz;
}

#define BIT(nz, n) (!!((nz) & (1 << (n))))

void VP8IteratorNzToBytes(VP8EncIteratorVariable* const it_var,
                          VP8EncIteratorPointer* const it) {
  int x = it_var->x_;
  uint32_t* nz = it->nz_p + x + 1;
  const int tnz = nz[0], lnz = nz[-1];
  int* const top_nz = it->top_nz_p;
  int* const left_nz = it->left_nz_p;

  top_nz[0] = BIT(tnz, 12);
  top_nz[1] = BIT(tnz, 13);
  top_nz[2] = BIT(tnz, 14);
  top_nz[3] = BIT(tnz, 15);
  top_nz[4] = BIT(tnz, 18);
  top_nz[5] = BIT(tnz, 19);
  top_nz[6] = BIT(tnz, 22);
  top_nz[7] = BIT(tnz, 23);
  top_nz[8] = BIT(tnz, 24);

  left_nz[0] = BIT(lnz,  3);
  left_nz[1] = BIT(lnz,  7);
  left_nz[2] = BIT(lnz, 11);
  left_nz[3] = BIT(lnz, 15);
  left_nz[4] = BIT(lnz, 17);
  left_nz[5] = BIT(lnz, 19);
  left_nz[6] = BIT(lnz, 21);
  left_nz[7] = BIT(lnz, 23);
}

void VP8IteratorBytesToNz(VP8EncIteratorVariable* const it_var,
                          VP8EncIteratorPointer* const it) {
  int x = it_var->x_;
  uint32_t nz = 0;
  const int* const top_nz = it->top_nz_p;
  const int* const left_nz = it->left_nz_p;
  nz |= (top_nz[0] << 12) | (top_nz[1] << 13);
  nz |= (top_nz[2] << 14) | (top_nz[3] << 15);
  nz |= (top_nz[4] << 18) | (top_nz[5] << 19);
  nz |= (top_nz[6] << 22) | (top_nz[7] << 23);
  nz |= (top_nz[8] << 24);  
  nz |= (left_nz[0] << 3) | (left_nz[1] << 7);
  nz |= (left_nz[2] << 11);
  nz |= (left_nz[4] << 17) | (left_nz[6] << 21);

  it->nz_p[x + 1] = nz;
}

int ReconstructIntra16(VP8EncIteratorVariable* const it_var,
                       VP8EncIteratorPointer* const it,
                       VP8ModeScore* const rd,
                       VP8Matrix* matrix_y1_p,
                       VP8Matrix* matrix_y2_p,
                       uint8_t* yuv_out,
                       int mode) {
  int x = it_var->x_;
  const uint8_t* const ref = it->yuv_p_p + VP8I16ModeOffsets[mode];
  const uint8_t* const src = it->yuv_in_p + Y_OFF_ENC;
  VP8Matrix* const dqm_y1 = matrix_y1_p + it->mb_info_p[5 * x + 3];  

  VP8Matrix* const dqm_y2 = matrix_y2_p + it->mb_info_p[5 * x + 3];
  int nz = 0;
  int n;
  int16_t tmp[16][16], dc_tmp[16];
  int i, j;

  for (n = 0; n < 16; n += 2) {
    FTransform2(src + VP8Scan[n], ref + VP8Scan[n], tmp[n]);
  }
  FTransformWHT(tmp[0], dc_tmp);
  nz |= QuantizeBlockWHT(dc_tmp, rd, dqm_y2) << 24;

  for (n = 0; n < 16; n += 2) {
    tmp[n][0] = tmp[n + 1][0] = 0;
    nz |= Quantize2Blocks(tmp[n], rd->y_ac_levels[n], dqm_y1) << n;
  }

  TransformWHT(dc_tmp, tmp[0]);
  for (n = 0; n < 16; n += 2) {
    ITransform(ref + VP8Scan[n], tmp[n], yuv_out + VP8Scan[n], 1);
  }

  return nz;
}

int ReconstructUV(VP8EncIteratorVariable* const it_var,
                  VP8EncIteratorPointer* const it,
                  VP8ModeScore* const rd,
                  VP8Matrix* matrix_uv_p,
                  uint8_t* const yuv_out,
                  int mode) {
  int x = it_var->x_;
  const uint8_t* const ref = it->yuv_p_p + VP8UVModeOffsets[mode];
  const uint8_t* const src = it->yuv_in_p + U_OFF_ENC;
  VP8Matrix* const dqm_uv = matrix_uv_p + it->mb_info_p[5 * x + 3];
  int nz = 0;
  int n;
  int16_t tmp[8][16];

  for (n = 0; n < 8; n += 2) {
    FTransform2(src + VP8ScanUV[n], ref + VP8ScanUV[n], tmp[n]);
  }

  for (n = 0; n < 8; n += 2) {
    nz |= Quantize2Blocks(tmp[n], rd->uv_levels[n], dqm_uv) << n;
  }

  for (n = 0; n < 8; n += 2) {
    ITransform(ref + VP8ScanUV[n], tmp[n], yuv_out + VP8ScanUV[n], 1);
  }
  return (nz << 16);
}

static int TTransform(const uint8_t* in, const uint16_t* w) {
  int sum = 0;
  int tmp[16];
  int i;
  for (i = 0; i < 4; ++i, in += BPS) {
    const int a0 = in[0] + in[2];
    const int a1 = in[1] + in[3];
    const int a2 = in[1] - in[3];
    const int a3 = in[0] - in[2];
    tmp[0 + i * 4] = a0 + a1;
    tmp[1 + i * 4] = a3 + a2;
    tmp[2 + i * 4] = a3 - a2;
    tmp[3 + i * 4] = a0 - a1;
  }
  for (i = 0; i < 4; ++i, ++w) {
    const int a0 = tmp[0 + i] + tmp[8 + i];
    const int a1 = tmp[4 + i] + tmp[12+ i];
    const int a2 = tmp[4 + i] - tmp[12+ i];
    const int a3 = tmp[0 + i] - tmp[8 + i];
    const int b0 = a0 + a1;
    const int b1 = a3 + a2;
    const int b2 = a3 - a2;
    const int b3 = a0 - a1;

    sum += w[ 0] * abs(b0);
    sum += w[ 4] * abs(b1);
    sum += w[ 8] * abs(b2);
    sum += w[12] * abs(b3);
  }
  return sum;
}

void SetResidualCoeffs(const int16_t* const coeffs,
                       VP8Residual* const res) {
  int n;
  res->last = -1;
  for (n = 15; n >= 0; --n) {
    if (coeffs[n]) {
      res->last = n;
      break;
    }
  }

  for (n = 0; n < 16; n++) {
    res->coeffs[n] = coeffs[n];
  }
}

static int Disto4x4(const uint8_t* const a, const uint8_t* const b,
                    const uint16_t* const w) {
  const int sum1 = TTransform(a, w);
  const int sum2 = TTransform(b, w);
  return abs(sum2 - sum1) >> 5;
}

static int Disto16x16(const uint8_t* const a, const uint8_t* const b,
                      const uint16_t* const w) {
  int D = 0;
  int x, y;
  for (y = 0; y < 16 * BPS; y += 4 * BPS) {
    for (x = 0; x < 16; x += 4) {
      D += Disto4x4(a + x + y, b + x + y, w);
    }
  }
  return D;
}

void VP8InitResidual(int first, int coeff_type,
                     VP8EncLoopPointer *enc, VP8Residual* const res) {
  res->coeff_type = coeff_type;

  res->first = first;
}

int VP8LevelCost(const uint16_t* const table, int level) { 
  int ret = VP8LevelFixedCosts[level] + table[(level > MAX_VARIABLE_LEVEL) ? MAX_VARIABLE_LEVEL : level];
  return ret;
}

static int GetResidualCost(int ctx0, const VP8Residual* const res, VP8EncLoopPointer *encloop) {
  int n = res->first;

  const int p0 = encloop->coeffs_p[res->coeff_type*NUM_BANDS*NUM_CTX*NUM_PROBAS + n*NUM_CTX*NUM_PROBAS + ctx0*NUM_PROBAS + 0];


  const uint16_t* t = encloop->remapped_costs_p[res->coeff_type*16*NUM_CTX + n*NUM_CTX + ctx0]; 

  int cost = (ctx0 == 0) ? VP8BitCost(1, p0) : 0;

  if (res->last < 0) {
    return VP8BitCost(0, p0);
  }

  for (; n < res->last; ++n) {
    const int v = abs(res->coeffs[n]);

    const int ctx = (v >= 2) ? 2 : v;
    cost += VP8LevelCost(t, v); 

    t = encloop->remapped_costs_p[res->coeff_type*16*NUM_CTX + (n+1)*NUM_CTX + ctx]; 
  }

  {
    const int v = abs(res->coeffs[n]);

    assert(v != 0);
    cost += VP8LevelCost(t, v);
    if (n < 15) {
      const int b = VP8EncBands[n + 1];
      const int ctx = (v == 1) ? 1 : 2;
      const int last_p0 = encloop->coeffs_p[res->coeff_type*NUM_BANDS*NUM_CTX*NUM_PROBAS + b*NUM_CTX*NUM_PROBAS + ctx*NUM_PROBAS + 0];
      cost += VP8BitCost(0, last_p0);
    }
  }
  return cost;
}

int VP8GetCostLuma16(VP8EncIteratorVariable* const it_var,
                     VP8EncIteratorPointer* const it,
                     const VP8ModeScore* const rd,
                     VP8EncLoopPointer *encloop) {
  VP8Residual res;
  VP8EncLoopPointer* enc = encloop;
  int x, y;
  int R = 0;

  VP8IteratorNzToBytes(it_var, it);   

  VP8InitResidual(0, 1, enc, &res);
  SetResidualCoeffs(rd->y_dc_levels, &res);

  R += GetResidualCost(it->top_nz_p[8] + it->left_nz_p[8], &res, enc);

  VP8InitResidual(1, 0, enc, &res);
  for (y = 0; y < 4; ++y) {
    for (x = 0; x < 4; ++x) {
      const int ctx = it->top_nz_p[x] + it->left_nz_p[y];
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
      R += GetResidualCost(ctx, &res, enc);
      it->top_nz_p[x] = it->left_nz_p[y] = (res.last >= 0);
    }
  }

  return R;
}

static score_t IsFlat(const int16_t* levels, int num_blocks, score_t thresh) {
  int ret = 1;
  int quit_flag = 0;
  score_t score = 0;
  while (num_blocks-- > 0) {      
    int i;
    for (i = 1; i < 16; ++i) {    
      score += (levels[i] != 0);
      if (score > thresh) {
        quit_flag = 1;
        ret = 0;
        break;
      }
    }
    if (quit_flag == 1) {
      break;
    }
    levels += 16;
  }
  return ret;
}

void SetRDScore(int lambda, VP8ModeScore* const rd) {
  rd->score = (rd->R + rd->H) * lambda + RD_DISTO_MULT * (rd->D + rd->SD);
}

static void SwapModeScore(VP8ModeScore** a, VP8ModeScore** b) {
  VP8ModeScore* const tmp = *a;
  *a = *b;
  *b = tmp;
}

static void SwapPtrOrg(uint8_t** a, uint8_t** b) {
  uint8_t* const tmp = *a;
  *a = *b;
  *b = tmp;
}

static void SwapPtr(uint8_t* a, uint8_t* b) {

  uint8_t   yuv_out_tmp[YUV_SIZE_ENC];
  int i = 0;
  for (i = 0; i < YUV_SIZE_ENC; i++) {
    yuv_out_tmp[i] = a[i];
  }
  for (i = 0; i < YUV_SIZE_ENC; i++) {
    a[i] = b[i];
  }
  for (i = 0; i < YUV_SIZE_ENC; i++) {
    b[i] = yuv_out_tmp[i];
  }
}

static void SwapOut(VP8EncIteratorPointer* const it) {
  SwapPtr(it->yuv_out_p, it->yuv_out2_p); 
}


static void StoreMaxDelta(
                          EncloopSegmentData *segment_data,
                          int segment_index,
                          const int16_t DCs[16]) {
  const int v0 = abs(DCs[1]);
  const int v1 = abs(DCs[4]);
  const int v2 = abs(DCs[5]);
  int max_v = (v0 > v1) ? v1 : v0;
  max_v = (v2 > max_v) ? v2 : max_v;
  if (max_v > segment_data->max_edge[segment_index]) segment_data->max_edge[segment_index] = max_v;
}

void copyRD(VP8ModeScore* dst, VP8ModeScore* src) {
  dst->D = src->D;
  dst->SD = src->SD;
  dst->H = src->H;
  dst->R = src->R;
  dst->score = src->score;
  dst->mode_i16 = src->mode_i16;
  dst->mode_uv = src->mode_uv;
  dst->nz = src->nz;
  int i, j;
  for (i = 0; i < 16; i++) {
    dst->y_dc_levels[i] = src->y_dc_levels[i];
    dst->modes_i4[i] = src->modes_i4[i];
  }

  for (i = 0; i < 16; i++) {
    for (j = 0; j < 16; j++) {
      dst->y_ac_levels[i][j] = src->y_ac_levels[i][j];
    }
  }

  for (i = 0; i < 8; i++) {
    for (j = 0; j < 16; j++) {
      dst->uv_levels[i][j] = src->uv_levels[i][j];
    }
  }
}

static void PickBestIntra16(VP8EncIteratorVariable* const it_var,
                            VP8EncIteratorPointer* const it,
                            VP8ModeScore* rd,
                            VP8Matrix* matrix_y1_p,
                            VP8Matrix* matrix_y2_p,
                            VP8Matrix* matrix_uv_p,
                            EncloopSegmentData *segment_data,
                            VP8EncLoopPointer *encloop) {
  const int kNumBlocks = 16;
  int x = it_var->x_;

  int segment_index = it->mb_info_p[5 * x + 3];
  const int lambda = segment_data->lambda_i16[segment_index];
  const int tlambda = segment_data->tlambda[segment_index];;

  const uint8_t* const src = it->yuv_in_p + Y_OFF_ENC;
  VP8ModeScore rd_tmp;
  VP8ModeScore* rd_cur = &rd_tmp;
  VP8ModeScore* rd_best = rd;
  int mode;
  int best_changed = 0;

  rd->mode_i16 = -1;

  for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
    uint8_t* const tmp_dst = it->yuv_out2_p + Y_OFF_ENC;  
    rd_cur->mode_i16 = mode;

    rd_cur->nz = ReconstructIntra16(it_var, it, rd_cur, matrix_y1_p, matrix_y2_p, tmp_dst, mode);

    rd_cur->D = SSE16x16(src, tmp_dst);
    rd_cur->SD =
	  tlambda ? MULT_8B(tlambda, Disto16x16(src, tmp_dst, kWeightY)) : 0;
    rd_cur->H = VP8FixedCostsI16[mode];

    rd_cur->R = VP8GetCostLuma16(it_var, it, rd_cur, encloop);

    if (mode > 0 &&
        IsFlat(rd_cur->y_ac_levels[0], kNumBlocks, FLATNESS_LIMIT_I16)) {
      rd_cur->R += FLATNESS_PENALTY * kNumBlocks;
    }

    SetRDScore(lambda, rd_cur);
    if (mode == 0 || rd_cur->score < rd_best->score) {

      VP8ModeScore tmp;
      copyRD(&tmp, rd_best);
      copyRD(rd_best, rd_cur);
      copyRD(rd_cur, &tmp);
      SwapOut(it);
    }

  }
  copyRD(rd, rd_best);

  SetRDScore(segment_data->lambda_mode[segment_index], rd);   
  VP8SetIntra16Mode(it_var, it, rd->mode_i16);

  if ((rd->nz & 0xffff) == 0 && rd->D > segment_data->min_disto[segment_index]) {
    StoreMaxDelta(segment_data, segment_index, rd->y_dc_levels);
  }
}

void VP8SetIntra4Mode(
					  VP8EncIteratorVariable* const it_var,
					  VP8EncIteratorPointer* const it,
					  const uint8_t* modes) {
  int x = it_var->x_;
  uint8_t* preds = it->preds_p + it_var->preds_w + 1 + it_var->y_ * 4 * it_var->preds_w +  4 * it_var->x_;
  int y;
  int z;
  for (y = 4; y > 0; --y) {
    for (z = 0; z < 4; z++) {
      preds[z] = modes[z];
    }
    preds += it_var->preds_w;
    modes += 4;
  }
  it->mb_info_p[5 * x + 0] = 0;
}

int VP8IteratorRotateI4(
						VP8EncIteratorVariable* const it_var,
						VP8EncIteratorPointer* const it,
						const uint8_t* const yuv_out) {
  int ret = 1;
  const uint8_t* const blk = yuv_out + VP8Scan[it_var->i4_];
  uint8_t* const top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  int i;

  for (i = 0; i <= 3; ++i) {
    top[-4 + i] = blk[i + 3 * BPS];   
  }
  if ((it_var->i4_ & 3) != 3) {  
    for (i = 0; i <= 2; ++i) {        
      top[i] = blk[3 + (2 - i) * BPS];
    }
  } else {  
    for (i = 0; i <= 3; ++i) {
      top[i] = top[i + 4];
    }
  }

  ++it_var->i4_;
  if (it_var->i4_ == 16) {    
    ret = 0;
  }

  return ret;
}

void Copy(const uint8_t* src, uint8_t* dst, int w, int h) {
  int y;
  for (y = 0; y < h; ++y) {
    int i;
    for (i = 0; i < w; i++) {
      dst[i] = src[i];
    }
    src += BPS;
    dst += BPS;
  }
}

void Copy4x4(const uint8_t* src, uint8_t* dst) {
  Copy(src, dst, 4, 4);
}

void Copy16x8(const uint8_t* src, uint8_t* dst) {
  Copy(src, dst, 16, 8);
}

static void AddScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
  dst->D  += src->D;
  dst->SD += src->SD;
  dst->R  += src->R;
  dst->H  += src->H;
  dst->nz |= src->nz;     
  dst->score += src->score;
}

static void CopyScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
  dst->D  = src->D;
  dst->SD = src->SD;
  dst->R  = src->R;
  dst->H  = src->H;
  dst->nz = src->nz;      
  dst->score = src->score;
}

int VP8GetCostLuma4(
					VP8EncIteratorVariable* const it_var,
					VP8EncIteratorPointer* const it,
					const int16_t levels[16],
					VP8EncLoopPointer *encloop) {
  const int x = (it_var->i4_ & 3), y = (it_var->i4_ >> 2);
  VP8Residual res;
  int R = 0;
  int ctx;

  VP8InitResidual(0, 3, encloop, &res);
  ctx = it->top_nz_p[x] + it->left_nz_p[y];
  SetResidualCoeffs(levels, &res);

  R += GetResidualCost(ctx, &res, encloop);
  return R;
}

int ReconstructIntra4(
                      VP8EncIteratorVariable* const it_var,
                      VP8EncIteratorPointer* const it,
                      int16_t levels[16],
                      const uint8_t* const src,
                      uint8_t* const yuv_out,
                      int mode,
                      VP8Matrix* matrix_y1_p,
                      VP8Matrix* matrix_y2_p) {
  int x = it_var->x_;
  const uint8_t* const ref = it->yuv_p_p + VP8I4ModeOffsets[mode];
  VP8Matrix* const dqm_y1 = matrix_y1_p + it->mb_info_p[5 * x + 3];  
  int nz = 0;
  int16_t tmp[16];

  FTransform(src, ref, tmp);

  nz = QuantizeBlock(tmp, levels, dqm_y1);

  ITransform(ref, tmp, yuv_out, 0);
  return nz;
}

#define DST(x, y) dst[(x) + (y) * BPS]
#define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
#define AVG2(a, b) (((a) + (b) + 1) >> 1)

static void VE4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const uint8_t vals[4] = {
    AVG3(top[-1], top[0], top[1]),
    AVG3(top[ 0], top[1], top[2]),
    AVG3(top[ 1], top[2], top[3]),
    AVG3(top[ 2], top[3], top[4])
  };
  int i, j;
  for (i = 0; i < 4; ++i) {
    for (j = 0; j < 4; j++) {
      dst[i * BPS + j] = vals[j];
    }
  }
}
void WebPUint32ToMem(uint8_t* const ptr, uint32_t val) {
  *(uint32_t*)ptr = val;
}

static void HE4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int X = top[-1];
  const int I = top[-2];
  const int J = top[-3];
  const int K = top[-4];
  const int L = top[-5];
  WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(X, I, J));
  WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(I, J, K));
  WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(J, K, L));
  WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(K, L, L));
}

static void DC4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  uint32_t dc = 4;
  int i;
  for (i = 0; i < 4; ++i) dc += top[i] + top[-5 + i];
  Fill(dst, dc >> 3, 4);
}

static void RD4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int X = top[-1];
  const int I = top[-2];
  const int J = top[-3];
  const int K = top[-4];
  const int L = top[-5];
  const int A = top[0];
  const int B = top[1];
  const int C = top[2];
  const int D = top[3];
  DST(0, 3)                                     = AVG3(J, K, L);
  DST(0, 2) = DST(1, 3)                         = AVG3(I, J, K);
  DST(0, 1) = DST(1, 2) = DST(2, 3)             = AVG3(X, I, J);
  DST(0, 0) = DST(1, 1) = DST(2, 2) = DST(3, 3) = AVG3(A, X, I);
  DST(1, 0) = DST(2, 1) = DST(3, 2)             = AVG3(B, A, X);
  DST(2, 0) = DST(3, 1)                         = AVG3(C, B, A);
  DST(3, 0)                                     = AVG3(D, C, B);
}

static void LD4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int A = top[0];
  const int B = top[1];
  const int C = top[2];
  const int D = top[3];
  const int E = top[4];
  const int F = top[5];
  const int G = top[6];
  const int H = top[7];
  DST(0, 0)                                     = AVG3(A, B, C);
  DST(1, 0) = DST(0, 1)                         = AVG3(B, C, D);
  DST(2, 0) = DST(1, 1) = DST(0, 2)             = AVG3(C, D, E);
  DST(3, 0) = DST(2, 1) = DST(1, 2) = DST(0, 3) = AVG3(D, E, F);
  DST(3, 1) = DST(2, 2) = DST(1, 3)             = AVG3(E, F, G);
  DST(3, 2) = DST(2, 3)                         = AVG3(F, G, H);
  DST(3, 3)                                     = AVG3(G, H, H);
}

static void VR4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int X = top[-1];
  const int I = top[-2];
  const int J = top[-3];
  const int K = top[-4];
  const int A = top[0];
  const int B = top[1];
  const int C = top[2];
  const int D = top[3];
  DST(0, 0) = DST(1, 2) = AVG2(X, A);
  DST(1, 0) = DST(2, 2) = AVG2(A, B);
  DST(2, 0) = DST(3, 2) = AVG2(B, C);
  DST(3, 0)             = AVG2(C, D);

  DST(0, 3) =             AVG3(K, J, I);
  DST(0, 2) =             AVG3(J, I, X);
  DST(0, 1) = DST(1, 3) = AVG3(I, X, A);
  DST(1, 1) = DST(2, 3) = AVG3(X, A, B);
  DST(2, 1) = DST(3, 3) = AVG3(A, B, C);
  DST(3, 1) =             AVG3(B, C, D);
}

static void VL4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int A = top[0];
  const int B = top[1];
  const int C = top[2];
  const int D = top[3];
  const int E = top[4];
  const int F = top[5];
  const int G = top[6];
  const int H = top[7];
  DST(0, 0) =             AVG2(A, B);
  DST(1, 0) = DST(0, 2) = AVG2(B, C);
  DST(2, 0) = DST(1, 2) = AVG2(C, D);
  DST(3, 0) = DST(2, 2) = AVG2(D, E);

  DST(0, 1) =             AVG3(A, B, C);
  DST(1, 1) = DST(0, 3) = AVG3(B, C, D);
  DST(2, 1) = DST(1, 3) = AVG3(C, D, E);
  DST(3, 1) = DST(2, 3) = AVG3(D, E, F);
  DST(3, 2) = AVG3(E, F, G);
  DST(3, 3) = AVG3(F, G, H);
}

static void HU4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int I = top[-2];
  const int J = top[-3];
  const int K = top[-4];
  const int L = top[-5];
  DST(0, 0) =             AVG2(I, J);
  DST(2, 0) = DST(0, 1) = AVG2(J, K);
  DST(2, 1) = DST(0, 2) = AVG2(K, L);
  DST(1, 0) =             AVG3(I, J, K);
  DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
  DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
  DST(3, 2) = DST(2, 2) =
	DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
}

static void HD4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  const int X = top[-1];
  const int I = top[-2];
  const int J = top[-3];
  const int K = top[-4];
  const int L = top[-5];
  const int A = top[0];
  const int B = top[1];
  const int C = top[2];

  DST(0, 0) = DST(2, 1) = AVG2(I, X);
  DST(0, 1) = DST(2, 2) = AVG2(J, I);
  DST(0, 2) = DST(2, 3) = AVG2(K, J);
  DST(0, 3)             = AVG2(L, K);

  DST(3, 0)             = AVG3(A, B, C);
  DST(2, 0)             = AVG3(X, A, B);
  DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
  DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
  DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
  DST(1, 3)             = AVG3(L, K, J);
}

static void TM4(uint8_t* dst,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  int x, y;
  const uint8_t* const clip = clip1 + 255 - top[-1];
  for (y = 0; y < 4; ++y) {
    const uint8_t* const clip_table = clip + top[-2 - y];
    for (x = 0; x < 4; ++x) {
      dst[x] = clip_table[top[x]];
    }
    dst += BPS;
  }
}

static void Intra4Preds(
                        uint8_t* dst,
                        VP8EncIteratorVariable* const it_var,
                        VP8EncIteratorPointer* const it
						) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  DC4(I4DC4 + dst, it_var, it);
  TM4(I4TM4 + dst, it_var, it);
  VE4(I4VE4 + dst, it_var, it);
  HE4(I4HE4 + dst, it_var, it);
  RD4(I4RD4 + dst, it_var, it);
  VR4(I4VR4 + dst, it_var, it);
  LD4(I4LD4 + dst, it_var, it);
  VL4(I4VL4 + dst, it_var, it);
  HD4(I4HD4 + dst, it_var, it);
  HU4(I4HU4 + dst, it_var, it);
}

void VP8MakeIntra4Preds(
						VP8EncIteratorVariable* const it_var,
						VP8EncIteratorPointer* const it) {
  const uint8_t* top = it->i4_boundary_p + VP8TopLeftI4[it_var->i4_];
  Intra4Preds(it->yuv_p_p, it_var, it);
}

static const uint16_t* GetCostModeI4(
									 VP8EncIteratorVariable* const it_var,
									 VP8EncIteratorPointer* const it,
                                     const uint8_t modes[16]) {
  uint8_t* preds_tmp = it->preds_p + it_var->preds_w + 1 + it_var->y_ * 4 * it_var->preds_w +  4 * it_var->x_;
  const int preds_w = it_var->preds_w;
  const int x = (it_var->i4_ & 3), y = it_var->i4_ >> 2;
  const int left = (x == 0) ? preds_tmp[y * preds_w - 1] : modes[it_var->i4_ - 1];
  const int top = (y == 0) ? preds_tmp[-preds_w + x] : modes[it_var->i4_ - 4]; 
  return VP8FixedCostsI4[top][left];
}

void VP8IteratorStartI4(
						VP8EncIteratorVariable* const it_var,
						VP8EncIteratorPointer* const it) {
  uint8_t* left = it->y_left_p + 1;
  uint8_t* top = it->y_top_p + it_var->x_ * 16;
  int i;

  it_var->i4_ = 0;    

  for (i = 0; i < 17; ++i) {    
    it->i4_boundary_p[i] = left[15 - i];
  }
  for (i = 0; i < 16; ++i) {    
    it->i4_boundary_p[17 + i] = top[i];
  }
  if (it_var->x_ < it_var->mb_w - 1) {
    for (i = 16; i < 16 + 4; ++i) {
      it->i4_boundary_p[17 + i] = top[i];
    }
  } else {    
    for (i = 16; i < 16 + 4; ++i) {
      it->i4_boundary_p[17 + i] = it->i4_boundary_p[17 + 15];
    }
  }
  VP8IteratorNzToBytes(it_var, it);  
}

int PickBestIntra4(
				   VP8EncIteratorVariable* const it_var,
				   VP8EncIteratorPointer* const it,
				   VP8ModeScore* const rd,
				   VP8Matrix* matrix_y1_p,
				   VP8Matrix* matrix_y2_p,
				   VP8Matrix* matrix_uv_p,
				   EncloopSegmentData *segment_data,
				   VP8EncLoopPointer *encloop) {
  int x = it_var->x_;
  int segment_index = it->mb_info_p[5 * x + 3];
  const int lambda = segment_data->lambda_i4[segment_index];
  const int tlambda = segment_data->tlambda[segment_index];

  const uint8_t* const src0 = it->yuv_in_p + Y_OFF_ENC;
  uint8_t* const best_blocks = it->yuv_out2_p + Y_OFF_ENC;
  int total_header_bits = 0;
  VP8ModeScore rd_best;

  if (it_var->max_i4_header_bits == 0) {
    return 0;
  }
  InitScore(&rd_best);
  rd_best.H = 211;  
  SetRDScore(segment_data->lambda_mode[segment_index], &rd_best);

  VP8IteratorStartI4(it_var, it);
  do {
    const int kNumBlocks = 1;
    VP8ModeScore rd_i4;
    int mode;
    int best_mode = -1;
    const uint8_t* const src = src0 + VP8Scan[it_var->i4_];
    const uint16_t* const mode_costs = GetCostModeI4(it_var, it, rd->modes_i4);
    uint8_t* best_block = best_blocks + VP8Scan[it_var->i4_];
    uint8_t* tmp_dst = it->yuv_p_p + I4TMP;    
    int swap_flag = 0;

    InitScore(&rd_i4);
    VP8MakeIntra4Preds(it_var, it);
    for (mode = 0; mode < NUM_BMODES; ++mode) {
      VP8ModeScore rd_tmp;
      int16_t tmp_levels[16];

      if (swap_flag == 0) {
        rd_tmp.nz = ReconstructIntra4(it_var, it, tmp_levels, src, tmp_dst, mode, matrix_y1_p, matrix_y2_p) << it_var->i4_;

        rd_tmp.D = SSE4x4(src, tmp_dst);
        rd_tmp.SD = tlambda ? MULT_8B(tlambda, Disto4x4(src, tmp_dst, kWeightY)) : 0;
        rd_tmp.H = mode_costs[mode];
      } else {
        rd_tmp.nz = ReconstructIntra4(it_var, it, tmp_levels, src, best_block, mode, matrix_y1_p, matrix_y2_p) << it_var->i4_;
        rd_tmp.D = SSE4x4(src, best_block);
        rd_tmp.SD = tlambda ? MULT_8B(tlambda, Disto4x4(src, best_block, kWeightY)) : 0;
        rd_tmp.H = mode_costs[mode];
      }

      if (mode > 0 && IsFlat(tmp_levels, kNumBlocks, FLATNESS_LIMIT_I4)) {
        rd_tmp.R = FLATNESS_PENALTY * kNumBlocks;
      } else {
        rd_tmp.R = 0;
      }

      SetRDScore(lambda, &rd_tmp);
      if (best_mode >= 0 && rd_tmp.score >= rd_i4.score) continue;

      rd_tmp.R += VP8GetCostLuma4(it_var, it, tmp_levels, encloop);
      SetRDScore(lambda, &rd_tmp);

      if (best_mode < 0 || rd_tmp.score < rd_i4.score) {
        CopyScore(&rd_i4, &rd_tmp);
        best_mode = mode;
        swap_flag = swap_flag == 0 ? 1 : 0;
        int i = 0;
        int size = sizeof(rd_best.y_ac_levels[it_var->i4_]) / sizeof(rd_best.y_ac_levels[it_var->i4_][0]);
        for (i = 0; i < size; i++) {
          rd_best.y_ac_levels[it_var->i4_][i] = tmp_levels[i];
        }
      }
    }
    SetRDScore(segment_data->lambda_mode[segment_index], &rd_i4);
    AddScore(&rd_best, &rd_i4);
    if (rd_best.score >= rd->score) {
      return 0;
    }
    total_header_bits += (int)rd_i4.H;   
    if (total_header_bits > it_var->max_i4_header_bits) {
      return 0;
    }

    if (swap_flag == 1) {
      Copy4x4(tmp_dst, best_blocks + VP8Scan[it_var->i4_]);
    }
    rd->modes_i4[it_var->i4_] = best_mode;
    it->top_nz_p[it_var->i4_ & 3] = it->left_nz_p[it_var->i4_ >> 2] = (rd_i4.nz ? 1 : 0);
  } while (VP8IteratorRotateI4(it_var, it, best_blocks));
  
  CopyScore(rd, &rd_best);
  VP8SetIntra4Mode(it_var, it, rd->modes_i4);
  SwapOut(it);
  int i,j;
  for (i = 0; i < 16; i++) {
    for (j = 0; j < 16; j++) {
      rd->y_ac_levels[i][j] = rd_best.y_ac_levels[i][j];
    }
  }
  
  return 1;   
}

int VP8GetCostUV(
				 VP8EncIteratorVariable* const it_var,
				 VP8EncIteratorPointer* const it,
				 const VP8ModeScore* const rd,
				 VP8EncLoopPointer *encloop) {
  VP8Residual res;
  int ch, x, y;
  int R = 0;

  VP8IteratorNzToBytes(it_var, it);  

  VP8InitResidual(0, 2, encloop, &res);
  for (ch = 0; ch <= 2; ch += 2) {
    for (y = 0; y < 2; ++y) {
      for (x = 0; x < 2; ++x) {
        const int ctx = it->top_nz_p[4 + ch + x] + it->left_nz_p[4 + ch + y];
        SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
        R += GetResidualCost(ctx, &res, encloop);
        it->top_nz_p[4 + ch + x] = it->left_nz_p[4 + ch + y] = (res.last >= 0);
      }
    }
  }
  return R;
}

void VP8SetIntraUVMode(
					   VP8EncIteratorVariable* const it_var,
					   VP8EncIteratorPointer* const it,
					   int mode) {
  int x = it_var->x_;
  it->mb_info_p[5 * x + 1] = mode;
}

static void PickBestUV(
					   VP8EncIteratorVariable* const it_var,
					   VP8EncIteratorPointer* const it,
					   volatile VP8ModeScore* const rd,
					   VP8Matrix* matrix_y1_p,
					   VP8Matrix* matrix_y2_p,
					   VP8Matrix* matrix_uv_p,
					   EncloopSegmentData *segment_data,
					   VP8EncLoopPointer *encloop) {
  const int kNumBlocks = 8;
  int x = it_var->x_;
  int segment_index = it->mb_info_p[5 * x + 3];
  const int lambda = segment_data->lambda_uv[segment_index];

  const uint8_t* const src = it->yuv_in_p + U_OFF_ENC;
  uint8_t* tmp_dst = it->yuv_out2_p + U_OFF_ENC;  
  uint8_t* dst0 = it->yuv_out_p + U_OFF_ENC;
  uint8_t* dst = dst0;
  VP8ModeScore rd_best;
  int mode;

  rd->mode_uv = -1;
  InitScore(&rd_best);

  int swap_flag = 0;
  for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
    VP8ModeScore rd_uv;
    if (0 == swap_flag) {
      rd_uv.nz = ReconstructUV(it_var, it, &rd_uv, matrix_uv_p, tmp_dst, mode);

      rd_uv.D  = SSE16x8(src, tmp_dst);
    } else {
      rd_uv.nz = ReconstructUV(it_var, it, &rd_uv, matrix_uv_p, dst, mode);

      rd_uv.D  = SSE16x8(src, dst);
    }


    rd_uv.SD = 0;    
    rd_uv.H  = VP8FixedCostsUV[mode];
    rd_uv.R  = VP8GetCostUV(it_var, it, &rd_uv, encloop);
    if (mode > 0 && IsFlat(rd_uv.uv_levels[0], kNumBlocks, FLATNESS_LIMIT_UV)) {
      rd_uv.R += FLATNESS_PENALTY * kNumBlocks;
    }

    SetRDScore(lambda, &rd_uv);
    if (mode == 0 || rd_uv.score < rd_best.score) {
      CopyScore(&rd_best, &rd_uv);
      rd->mode_uv = mode;
      int i = 0;
      int j = 0;

      for (i = 0; i < 8; i++) {
        for (j = 0; j < 16; j++) {
          rd->uv_levels[i][j] = rd_uv.uv_levels[i][j];
        }
      }
      swap_flag = swap_flag == 0 ? 1 : 0;
    }

  }
  VP8SetIntraUVMode(it_var, it, rd->mode_uv);
  AddScore(rd, &rd_best);
  if (1 == swap_flag) {   
    Copy16x8(tmp_dst, dst0);
  }
}

int VP8Decimate(EncloopInputData* const input,
                VP8EncIteratorVariable* const it_var,
                VP8EncIteratorPointer* const it,
                VP8ModeScore* const rd,
                VP8Matrix* matrix_y1_p,
                VP8Matrix* matrix_y2_p,
                VP8Matrix* matrix_uv_p,
                EncloopSegmentData *segment_data,
                VP8EncLoopPointer *encloop) {

  int is_skipped;
  int rd_opt = input->rd_opt;
  const int method = input->method;

  InitScore(rd);
  int yuv_p_index = 0;
  VP8MakeLuma16Preds(it_var, it);

  VP8MakeChroma8Preds(it_var, it);

  PickBestIntra16(it_var, it, rd, matrix_y1_p, matrix_y2_p, matrix_uv_p, segment_data, encloop);

  if (method >= 2) {
    PickBestIntra4(it_var, it, rd ,matrix_y1_p, matrix_y2_p, matrix_uv_p, segment_data, encloop);
  }

  PickBestUV(it_var, it, rd ,matrix_y1_p, matrix_y2_p, matrix_uv_p, segment_data, encloop);

  is_skipped = (rd->nz == 0);
  VP8SetSkip(it_var, it, is_skipped);

  return is_skipped;
}

void VP8IteratorSaveBoundary(const VP8EncIteratorVariable* const it_var,
                             VP8EncIteratorPointer* const it) {
  int i;
  const int x = it_var->x_, y = it_var->y_;
  uint8_t* const y_top = it->y_top_p + 16 * x;
  uint8_t* const uv_top = it->uv_top_p + 16 * x;
  uint8_t* const y_left = it->y_left_p + 1;
  uint8_t* const u_left = it->uv_left_p + 1;
  uint8_t* const v_left = it->uv_left_p + 1 + 16;
  const uint8_t* const ysrc = it->yuv_out_p + Y_OFF_ENC;
  const uint8_t* const uvsrc = it->yuv_out_p + U_OFF_ENC;
  if (x < it_var->mb_w - 1) {   
    for (i = 0; i < 16; ++i) {
      y_left[i] = ysrc[15 + i * BPS];
    }
    for (i = 0; i < 8; ++i) {
      u_left[i] = uvsrc[7 + i * BPS];
      v_left[i] = uvsrc[15 + i * BPS];
    }
    y_left[-1] = y_top[15];
    u_left[-1] = uv_top[0 + 7];
    v_left[-1] = uv_top[8 + 7];
  }
  if (y < it_var->mb_h - 1) {  
    for (i = 0; i < 16; i++) {
      y_top[i] = ysrc[15 * BPS + i];
    }
    for (i = 0; i < 16; i++) {
      uv_top[i] = uvsrc[7 * BPS + i];
    }
  }
}

void VP8TBufferKernelInit(VP8TBufferKernel* const b, int page_size) {
  int i = 0;
  for (i = 0; i < PAGE_COUNT * TOKENS_COUNT_PER_PAGE; i++) {
    b->tokens_[i] = 0;
  }
  b->cur_page_ = 0;
  b->page_count_ = 0;
  b->left_ = 0;
  b->page_size_ = (page_size < MIN_PAGE_SIZE) ? MIN_PAGE_SIZE : page_size;
  b->error_ = 0;
  b->index_using_buf = 0;
}

static int TBufferNewPage(VP8TBufferKernel* const b) {
  if (!b->error_) {
    if (0 != b->page_count_) {
      b->cur_page_++;
      b->index_using_buf = b->index_using_buf == 1 ? 0: 1; 
    }

    b->page_count_++;
  }
  if (b->page_count_ >= 30) {
    printf("error: more page needed, please check %d >= %d \n", b->page_count_, PAGE_COUNT);
    b->error_ = 1;
    return 0;
  }

  b->left_ = b->page_size_;

  return 1;
}

#define TOKEN_ID(t, b, ctx)										\
  (NUM_PROBAS * ((ctx) + NUM_CTX * ((b) + NUM_BANDS * (t))))

static uint32_t AddToken(VP8TBufferKernel* const b,
						 uint32_t bit, uint32_t proba_idx) {
  assert(proba_idx < FIXED_PROBA_BIT);
  assert(bit <= 1);
  if (b->left_ > 0 || TBufferNewPage(b)) {
    const int slot = --b->left_;
    b->tokens_[b->index_using_buf * TOKENS_COUNT_PER_PAGE + slot] = (bit << 15) | proba_idx;
  }
  return bit;
}

static void AddConstantToken(VP8TBufferKernel* const b,
							 uint32_t bit, uint32_t proba) {
  assert(proba < 256);
  assert(bit <= 1);
  if (b->left_ > 0 || TBufferNewPage(b)) {
    const int slot = --b->left_;
    b->tokens_[b->index_using_buf * TOKENS_COUNT_PER_PAGE + slot] = (bit << 15) | FIXED_PROBA_BIT | proba;
  }
}

static int Record(int bit, proba_t* const stats) {
  proba_t p = *stats;
  if (p >= 0xffff0000u) {               
    p = ((p + 1u) >> 1) & 0x7fff7fffu;  
  }
  p += 0x00010000u + bit;
  *stats = p;
  return bit;
}

#define USE_LEVEL_CODE_TABLE

int VP8RecordCoeffs(int ctx, const VP8Residual* const res, VP8EncLoopPointer *encloop) {
  int n = res->first;
  int m = 0, pos = 0;
  uint32_t* ptr = encloop->stats_p;
  proba_t* s;

  pos = res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
	n * NUM_CTX * NUM_PROBAS +
	ctx * NUM_PROBAS;
  if (res->last  < 0) {
    m++;
    Record(0, &ptr[pos]); 
    return 0;
  }
  while (n <= res->last) {
    int v;
    m++;
    Record(1, &ptr[pos]);
    while ((v = res->coeffs[n++]) == 0) {
      m++;
      Record(0, &ptr[pos + 1]);
      s = encloop->stats_p +
		res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS +
		0 * NUM_PROBAS;
      pos = res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS + 0 * NUM_PROBAS;
    }
    m++;
    Record(1, &ptr[pos + 1]);
    m++;
    if (!Record(2u < (unsigned int)(v + 1), &ptr[pos + 2])) {  
      s = encloop->stats_p +
		res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS +
		1 * NUM_PROBAS;
      pos = res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS +
		1 * NUM_PROBAS;
    } else {
      v = abs(v);
#if !defined(USE_LEVEL_CODE_TABLE)
      if (!Record(v > 4, s + 3)) {
        if (Record(v != 2, s + 4))
          Record(v == 4, s + 5);
      } else if (!Record(v > 10, s + 6)) {
        Record(v > 6, s + 7);
      } else if (!Record((v >= 3 + (8 << 2)), s + 8)) {
        Record((v >= 3 + (8 << 1)), s + 9);
      } else {
        Record((v >= 3 + (8 << 3)), s + 10);
      }
#else
      if (v > MAX_VARIABLE_LEVEL) {
        v = MAX_VARIABLE_LEVEL;
      }

      {
        const int bits = VP8LevelCodes[v - 1][1];
        int pattern = VP8LevelCodes[v - 1][0];
        int i;
        for (i = 0; (pattern >>= 1) != 0; ++i) {
          const int mask = 2 << i;
          if (pattern & 1) {
			m++;
			Record(!!(bits & mask), &ptr[pos + 3 + i]);
          }
        }
      }
#endif
      s = encloop->stats_p +
		res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS +
		2 * NUM_PROBAS;
      pos = res->coeff_type * NUM_BANDS * NUM_CTX * NUM_PROBAS +
		VP8EncBands[n] * NUM_CTX * NUM_PROBAS +
		2 * NUM_PROBAS;
    }
  }
  if (n < 16){
	m++;
	Record(0, &ptr[pos]);
  }
  return 1;
}
int VP8RecordCoeffTokens(const int ctx, const int coeff_type,
                         const int first, const int last,
                         const int16_t* const coeffs,
                         VP8TBufferKernel* const tokens) {
  int n = first;
  uint32_t base_id = TOKEN_ID(coeff_type, n, ctx);
  if (!AddToken(tokens, g_last >= 0, base_id + 0)) {
    return 0;
  }
  while (n < 16) {
    const int c = coeffs[n++];
    const int sign = c < 0;
    const uint32_t v = sign ? -c : c;
    if (!AddToken(tokens, v != 0, base_id + 1)) {
      base_id = TOKEN_ID(coeff_type, VP8EncBands[n], 0);  
      continue;
    }
    if (!AddToken(tokens, v > 1, base_id + 2)) {
      base_id = TOKEN_ID(coeff_type, VP8EncBands[n], 1);  
    } else {
      if (!AddToken(tokens, v > 4, base_id + 3)) {
        if (AddToken(tokens, v != 2, base_id + 4))
          AddToken(tokens, v == 4, base_id + 5);
      } else if (!AddToken(tokens, v > 10, base_id + 6)) {
        if (!AddToken(tokens, v > 6, base_id + 7)) {
          AddConstantToken(tokens, v == 6, 159);
        } else {
          AddConstantToken(tokens, v >= 9, 165);
          AddConstantToken(tokens, !(v & 1), 145);
        }
      } else {
        int mask;
        const uint8_t* tab;
        uint32_t residue = v - 3;
        if (residue < (8 << 1)) {          
          AddToken(tokens, 0, base_id + 8);
          AddToken(tokens, 0, base_id + 9);
          residue -= (8 << 0);
          mask = 1 << 2;
          tab = VP8Cat3;
        } else if (residue < (8 << 2)) {   
          AddToken(tokens, 0, base_id + 8);
          AddToken(tokens, 1, base_id + 9);
          residue -= (8 << 1);
          mask = 1 << 3;
          tab = VP8Cat4;
        } else if (residue < (8 << 3)) {   
          AddToken(tokens, 1, base_id + 8);
          AddToken(tokens, 0, base_id + 10);
          residue -= (8 << 2);
          mask = 1 << 4;
          tab = VP8Cat5;
        } else {                         
          AddToken(tokens, 1, base_id + 8);
          AddToken(tokens, 1, base_id + 10);
          residue -= (8 << 3);
          mask = 1 << 10;
          tab = VP8Cat6;
        }
        while (mask) {
          AddConstantToken(tokens, !!(residue & mask), *tab++);
          mask >>= 1;
        }
      }
      base_id = TOKEN_ID(coeff_type, VP8EncBands[n], 2);  
    }
    AddConstantToken(tokens, sign, 128);
    if (n == 16 || !AddToken(tokens, n <= g_last, base_id + 0)) {
      return 1;   
    }
  }
  return 1;
}

int RecordTokens(
				 EncloopInputData* const input,
				 VP8EncIteratorVariable* const it_var,
				 VP8EncIteratorPointer* const it,
				 VP8ModeScore* const rd,
				 VP8Matrix* matrix_y1_p,
				 VP8Matrix* matrix_y2_p,
				 VP8Matrix* matrix_uv_p,
				 EncloopSegmentData *segment_data,
				 VP8EncLoopPointer *encloop,
				 VP8TBufferKernel* const tokens) {
  int x, y, ch;
  VP8Residual res;
  VP8EncLoopPointer * const enc = encloop;

  VP8IteratorNzToBytes(it_var, it);
  int i;
  if (it->mb_info_p[5 * it_var->x_ + 0] == 1) {   
    const int ctx = it->top_nz_p[8] + it->left_nz_p[8];
    VP8InitResidual(0, 1, enc, &res);
    SetResidualCoeffs(rd->y_dc_levels, &res);
    g_last = res.last;
    it->top_nz_p[8] = it->left_nz_p[8] =
	  VP8RecordCoeffTokens(ctx, 1,
						   res.first, res.last, res.coeffs, tokens);


    VP8RecordCoeffs(ctx, &res, encloop);
    VP8InitResidual(1, 0, enc, &res);
  } else {
    VP8InitResidual(0, 3, enc, &res);
  }

  for (y = 0; y < 4; ++y) {
    for (x = 0; x < 4; ++x) {
      const int ctx = it->top_nz_p[x] + it->left_nz_p[y];
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
      g_last = res.last;
      it->top_nz_p[x] = it->left_nz_p[y] =
		VP8RecordCoeffTokens(ctx, res.coeff_type,
							 res.first, res.last, res.coeffs, tokens);
      VP8RecordCoeffs(ctx, &res, encloop);
    }
  }
  VP8InitResidual(0, 2, enc, &res);
  for (ch = 0; ch <= 2; ch += 2) {
    for (y = 0; y < 2; ++y) {
      for (x = 0; x < 2; ++x) {
        const int ctx = it->top_nz_p[4 + ch + x] + it->left_nz_p[4 + ch + y];
        SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
      
        g_last = res.last;
        it->top_nz_p[4 + ch + x] = it->left_nz_p[4 + ch + y] =
		  VP8RecordCoeffTokens(ctx, 2,
							   res.first, res.last, res.coeffs, tokens);
        VP8RecordCoeffs(ctx, &res, encloop);
      }
    }
  }


  VP8IteratorBytesToNz(it_var, it);
  return !tokens->error_;
}

void enctokenloop (int* input_data,
				   uint8_t* y,                               
				   uint8_t* u,                               
				   uint8_t* v,                               
				   uint16_t* output) {

#pragma HLS INTERFACE m_axi port=input_data offset=slave bundle=gmem
#pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem
#pragma HLS INTERFACE m_axi port=u offset=slave bundle=gmem
#pragma HLS INTERFACE m_axi port=v offset=slave bundle=gmem
#pragma HLS INTERFACE m_axi port=output offset=slave bundle=gmem

#pragma HLS INTERFACE s_axilite port=input_data bundle=control
#pragma HLS INTERFACE s_axilite port=y bundle=control
#pragma HLS INTERFACE s_axilite port=u bundle=control
#pragma HLS INTERFACE s_axilite port=v bundle=control
#pragma HLS INTERFACE s_axilite port=output bundle=control

#pragma HLS INTERFACE s_axilite port=return bundle=control

  int i, j;
  int ok;

  int y_offset, uv_offset, mb_offset, preds_offset;
  int y_length, uv_length, mb_length, preds_length;

  VP8EncIteratorPointer it;
  VP8EncIteratorVariable it_variable;

  EncloopInputData input;
  VP8TBufferKernel tokens;

  // copy input_data to input.
  input.width = input_data[0];
  input.height = input_data[1];
  input.filter_sharpness = input_data[2];
  input.show_compressed = input_data[3];
  input.extra_info_type = input_data[4];
  input.stats_add = input_data[5];
  input.simple = input_data[6];
  input.num_parts = input_data[7];
  input.max_i4_header_bits = input_data[8];
  input.lf_stats_status = input_data[9];
  input.use_skip_proba = input_data[10];
  input.method = input_data[11];
  input.rd_opt = input_data[12];

  const int width  = input.width;
  const int height = input.height;
  const int mb_w = (width + 15) >> 4;
  const int mb_h = (height + 15) >> 4;
  const int preds_w = 4 * mb_w + 1;
  const int preds_h = 4 * mb_h + 1;
  const int y_stride = width;
  const int uv_stride = (width + 1) >> 1;
  const int uv_width = (width + 1) >> 1;
  const int uv_height = (height + 1) >> 1;
  const size_t top_size = mb_w * 16;

  uint8_t y_l[LARGEST_Y_STRIDE * 16];
  uint8_t u_l[LARGEST_UV_STRIDE * 8];
  uint8_t v_l[LARGEST_UV_STRIDE * 8];

  // used by VP8IteratorImport
  it_variable.y_stride_  = y_stride;
  it_variable.uv_stride_ = uv_stride;

  int index = 0;
  int buf_output = tokens.index_using_buf;

  printf("\n");
  printf("In kernel_enctokenloop \n");  
  printf("mb_h:  %d\n", mb_h);
  printf("mb_w:  %d\n", mb_w);
  printf("\n");

  // loop of h 
  for (int index_h = 0; index_h < mb_h;) {
  
	y_offset = index_h * y_stride * 16;
    y_length = y_stride * 16;

    uv_offset = index_h * uv_stride * 8;
    uv_length = uv_stride * 8;
   
	// read 16 lines
	memcpy(y_l, y + y_offset, y_length * sizeof(uint8_t));
    memcpy(u_l, u + uv_offset, uv_length * sizeof(uint8_t));
    memcpy(v_l, v + uv_offset, uv_length * sizeof(uint8_t));

    /* mb_offset = index_h * 5 * mb_w; */
    /* mb_length = 5 * mb_w; */
    
    for (int index_w = 0; index_w < mb_w; index_w++) {
     
	  g_x = index_w;
      g_y = index_h;

      index++;
      it_variable.x_ = index_w;

	  // re-construct y u v, output is in it
	  // it->yuv_in_p + Y_OFF_ENC
	  // it->yuv_in_p + U_OFF_ENC
	  // it->yuv_in_p + V_OFF_ENC
      VP8IteratorImport(&it, &it_variable, y_l, u_l, v_l);

	  /* printf("\n \n %d  %d  %d  %d  %d", */
	  /* 		 index_h, index_w, buf_output, */
	  /* 		 tokens.index_using_buf, tokens.cur_page_); */

	  int offset = (index_h * mb_w + index_w) * 24;

	  uint16_t tmp_y[16];
	  uint16_t tmp_u[8];
	  uint16_t tmp_v[8];

	  for(int s1=0;s1<16;s1++){
	  	tmp_y[s1] = it.yuv_in_p[s1+Y_OFF_ENC];
	  }
	  for(int s2=0;s2<8;s2++){
	  	tmp_u[s2] = it.yuv_in_p[s2+U_OFF_ENC];
	  }
	  for(int s3=0;s3<8;s3++){
	  	tmp_v[s3] = it.yuv_in_p[s3+V_OFF_ENC];
	  }


	  memcpy(output + offset, tmp_y,
	  		 16*sizeof(uint16_t));
	  memcpy(output + offset + 16, tmp_u,
	  		 8 * sizeof(uint16_t));
	  memcpy(output + offset + 16+8, tmp_v,
	  		 8 * sizeof(uint16_t));

    } // end of width

    index_h++;

  } // end of figure

  /* memcpy(output + tokens.cur_page_ * TOKENS_COUNT_PER_PAGE, */
  /*        tokens.tokens_ + buf_output * TOKENS_COUNT_PER_PAGE, */
  /*        TOKENS_COUNT_PER_PAGE * sizeof(uint16_t)); */
}
